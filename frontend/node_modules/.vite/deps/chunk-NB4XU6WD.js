import {
  ApiController,
  BalanceUtil,
  BlockchainApiController,
  ChainController,
  ConnectionController,
  ConnectorController,
  ConstantsUtil,
  ConstantsUtil2,
  CoreHelperUtil,
  EventsController,
  MELD_PUBLIC_KEY,
  ModalController,
  NumberUtil,
  ONRAMP_PROVIDERS,
  OptionsController,
  ParseUtil,
  ProviderController,
  RouterController,
  SnackController,
  StorageUtil,
  SwapApiUtil,
  UserRejectedRequestError,
  W3mFrameRpcConstants,
  getActiveCaipNetwork,
  getActiveNetworkTokenAddress,
  getPreferredAccountType,
  proxy,
  subscribe,
  subscribeKey,
  withErrorBoundary
} from "./chunk-3FNXZUWX.js";
import {
  esm_exports,
  require_blakejs,
  require_cjs,
  require_cjs2,
  require_cjs3,
  require_events
} from "./chunk-FCHOTNAR.js";
import {
  __toESM
} from "./chunk-DI52DQAC.js";

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/sign-client/dist/index.js
var import_events4 = __toESM(require_events());

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/core/dist/index.js
var import_events3 = __toESM(require_events());

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/types/dist/index.js
var import_events2 = __toESM(require_events());

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/core/dist/index.js
var import_time2 = __toESM(require_cjs());

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/dist/index.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());
var import_blakejs = __toESM(require_blakejs());
var Oe = BigInt(2 ** 32 - 1);
var Nr = BigInt(32);
function Ur(t, e = false) {
  return e ? { h: Number(t & Oe), l: Number(t >> Nr & Oe) } : { h: Number(t >> Nr & Oe) | 0, l: Number(t & Oe) | 0 };
}
function _r(t, e = false) {
  const n2 = t.length;
  let r2 = new Uint32Array(n2), o2 = new Uint32Array(n2);
  for (let s = 0; s < n2; s++) {
    const { h: i2, l: c } = Ur(t[s], e);
    [r2[s], o2[s]] = [i2, c];
  }
  return [r2, o2];
}
var Rr = (t, e, n2) => t >>> n2;
var $r = (t, e, n2) => t << 32 - n2 | e >>> n2;
var St = (t, e, n2) => t >>> n2 | e << 32 - n2;
var Ot = (t, e, n2) => t << 32 - n2 | e >>> n2;
var de = (t, e, n2) => t << 64 - n2 | e >>> n2 - 32;
var he = (t, e, n2) => t >>> n2 - 32 | e << 64 - n2;
var Pi = (t, e) => e;
var Hi = (t, e) => t;
var Di = (t, e, n2) => t << n2 | e >>> 32 - n2;
var Vi = (t, e, n2) => e << n2 | t >>> 32 - n2;
var Mi = (t, e, n2) => e << n2 - 32 | t >>> 64 - n2;
var Ki = (t, e, n2) => t << n2 - 32 | e >>> 64 - n2;
function dt(t, e, n2, r2) {
  const o2 = (e >>> 0) + (r2 >>> 0);
  return { h: t + n2 + (o2 / 2 ** 32 | 0) | 0, l: o2 | 0 };
}
var fn = (t, e, n2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0);
var an = (t, e, n2, r2) => e + n2 + r2 + (t / 2 ** 32 | 0) | 0;
var qi = (t, e, n2, r2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0) + (r2 >>> 0);
var Fi = (t, e, n2, r2, o2) => e + n2 + r2 + o2 + (t / 2 ** 32 | 0) | 0;
var Zi = (t, e, n2, r2, o2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0) + (r2 >>> 0) + (o2 >>> 0);
var Gi = (t, e, n2, r2, o2, s) => e + n2 + r2 + o2 + s + (t / 2 ** 32 | 0) | 0;
var Xt = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function Ne(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function mt(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function ht(t, ...e) {
  if (!Ne(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function Ue(t) {
  if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  mt(t.outputLen), mt(t.blockLen);
}
function Nt(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function un(t, e) {
  ht(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
function pe(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function lt(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
function ln(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function bt(t, e) {
  return t << 32 - e | t >>> e;
}
var Tr = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Cr(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
var wt = Tr ? (t) => t : (t) => Cr(t);
function zi(t) {
  for (let e = 0; e < t.length; e++) t[e] = Cr(t[e]);
  return t;
}
var Ut = Tr ? (t) => t : zi;
var jr = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
var Yi = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Jt(t) {
  if (ht(t), jr) return t.toHex();
  let e = "";
  for (let n2 = 0; n2 < t.length; n2++) e += Yi[t[n2]];
  return e;
}
var vt = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Lr(t) {
  if (t >= vt._0 && t <= vt._9) return t - vt._0;
  if (t >= vt.A && t <= vt.F) return t - (vt.A - 10);
  if (t >= vt.a && t <= vt.f) return t - (vt.a - 10);
}
function _e(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  if (jr) return Uint8Array.fromHex(t);
  const e = t.length, n2 = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const r2 = new Uint8Array(n2);
  for (let o2 = 0, s = 0; o2 < n2; o2++, s += 2) {
    const i2 = Lr(t.charCodeAt(s)), c = Lr(t.charCodeAt(s + 1));
    if (i2 === void 0 || c === void 0) {
      const f4 = t[s] + t[s + 1];
      throw new Error('hex string expected, got non-hex character "' + f4 + '" at index ' + s);
    }
    r2[o2] = i2 * 16 + c;
  }
  return r2;
}
function kr(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function pt(t) {
  return typeof t == "string" && (t = kr(t)), ht(t), t;
}
function _t(...t) {
  let e = 0;
  for (let r2 = 0; r2 < t.length; r2++) {
    const o2 = t[r2];
    ht(o2), e += o2.length;
  }
  const n2 = new Uint8Array(e);
  for (let r2 = 0, o2 = 0; r2 < t.length; r2++) {
    const s = t[r2];
    n2.set(s, o2), o2 += s.length;
  }
  return n2;
}
var Re = class {
};
function ge(t) {
  const e = (r2) => t().update(pt(r2)).digest(), n2 = t();
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = () => t(), e;
}
function Wi(t) {
  const e = (r2, o2) => t(o2).update(pt(r2)).digest(), n2 = t({});
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = (r2) => t(r2), e;
}
function Mt(t = 32) {
  if (Xt && typeof Xt.getRandomValues == "function") return Xt.getRandomValues(new Uint8Array(t));
  if (Xt && typeof Xt.randomBytes == "function") return Uint8Array.from(Xt.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
var Xi = BigInt(0);
var be = BigInt(1);
var Ji = BigInt(2);
var Qi = BigInt(7);
var tc = BigInt(256);
var ec = BigInt(113);
var Pr = [];
var Hr = [];
var Dr = [];
for (let t = 0, e = be, n2 = 1, r2 = 0; t < 24; t++) {
  [n2, r2] = [r2, (2 * n2 + 3 * r2) % 5], Pr.push(2 * (5 * r2 + n2)), Hr.push((t + 1) * (t + 2) / 2 % 64);
  let o2 = Xi;
  for (let s = 0; s < 7; s++) e = (e << be ^ (e >> Qi) * ec) % tc, e & Ji && (o2 ^= be << (be << BigInt(s)) - be);
  Dr.push(o2);
}
var Vr = _r(Dr, true);
var nc = Vr[0];
var rc = Vr[1];
var Mr = (t, e, n2) => n2 > 32 ? Mi(t, e, n2) : Di(t, e, n2);
var Kr = (t, e, n2) => n2 > 32 ? Ki(t, e, n2) : Vi(t, e, n2);
function oc(t, e = 24) {
  const n2 = new Uint32Array(10);
  for (let r2 = 24 - e; r2 < 24; r2++) {
    for (let i2 = 0; i2 < 10; i2++) n2[i2] = t[i2] ^ t[i2 + 10] ^ t[i2 + 20] ^ t[i2 + 30] ^ t[i2 + 40];
    for (let i2 = 0; i2 < 10; i2 += 2) {
      const c = (i2 + 8) % 10, f4 = (i2 + 2) % 10, u = n2[f4], a = n2[f4 + 1], l2 = Mr(u, a, 1) ^ n2[c], d3 = Kr(u, a, 1) ^ n2[c + 1];
      for (let h3 = 0; h3 < 50; h3 += 10) t[i2 + h3] ^= l2, t[i2 + h3 + 1] ^= d3;
    }
    let o2 = t[2], s = t[3];
    for (let i2 = 0; i2 < 24; i2++) {
      const c = Hr[i2], f4 = Mr(o2, s, c), u = Kr(o2, s, c), a = Pr[i2];
      o2 = t[a], s = t[a + 1], t[a] = f4, t[a + 1] = u;
    }
    for (let i2 = 0; i2 < 50; i2 += 10) {
      for (let c = 0; c < 10; c++) n2[c] = t[i2 + c];
      for (let c = 0; c < 10; c++) t[i2 + c] ^= ~n2[(c + 2) % 10] & n2[(c + 4) % 10];
    }
    t[0] ^= nc[r2], t[1] ^= rc[r2];
  }
  lt(n2);
}
var Jn = class _Jn extends Re {
  constructor(e, n2, r2, o2 = false, s = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e, this.suffix = n2, this.outputLen = r2, this.enableXOF = o2, this.rounds = s, mt(r2), !(0 < e && e < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = pe(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Ut(this.state32), oc(this.state32, this.rounds), Ut(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Nt(this), e = pt(e), ht(e);
    const { blockLen: n2, state: r2 } = this, o2 = e.length;
    for (let s = 0; s < o2; ) {
      const i2 = Math.min(n2 - this.pos, o2 - s);
      for (let c = 0; c < i2; c++) r2[this.pos++] ^= e[s++];
      this.pos === n2 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e, suffix: n2, pos: r2, blockLen: o2 } = this;
    e[r2] ^= n2, (n2 & 128) !== 0 && r2 === o2 - 1 && this.keccak(), e[o2 - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Nt(this, false), ht(e), this.finish();
    const n2 = this.state, { blockLen: r2 } = this;
    for (let o2 = 0, s = e.length; o2 < s; ) {
      this.posOut >= r2 && this.keccak();
      const i2 = Math.min(r2 - this.posOut, s - o2);
      e.set(n2.subarray(this.posOut, this.posOut + i2), o2), this.posOut += i2, o2 += i2;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return mt(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (un(e, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, lt(this.state);
  }
  _cloneInto(e) {
    const { blockLen: n2, suffix: r2, outputLen: o2, rounds: s, enableXOF: i2 } = this;
    return e || (e = new _Jn(n2, r2, o2, i2, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = r2, e.outputLen = o2, e.enableXOF = i2, e.destroyed = this.destroyed, e;
  }
};
var sc = (t, e, n2) => ge(() => new Jn(e, t, n2));
var ic = sc(1, 136, 256 / 8);
function cc(t, e, n2, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r2);
  const o2 = BigInt(32), s = BigInt(4294967295), i2 = Number(n2 >> o2 & s), c = Number(n2 & s), f4 = r2 ? 4 : 0, u = r2 ? 0 : 4;
  t.setUint32(e + f4, i2, r2), t.setUint32(e + u, c, r2);
}
function fc(t, e, n2) {
  return t & e ^ ~t & n2;
}
function ac(t, e, n2) {
  return t & e ^ t & n2 ^ e & n2;
}
var qr = class extends Re {
  constructor(e, n2, r2, o2) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e, this.outputLen = n2, this.padOffset = r2, this.isLE = o2, this.buffer = new Uint8Array(e), this.view = ln(this.buffer);
  }
  update(e) {
    Nt(this), e = pt(e), ht(e);
    const { view: n2, buffer: r2, blockLen: o2 } = this, s = e.length;
    for (let i2 = 0; i2 < s; ) {
      const c = Math.min(o2 - this.pos, s - i2);
      if (c === o2) {
        const f4 = ln(e);
        for (; o2 <= s - i2; i2 += o2) this.process(f4, i2);
        continue;
      }
      r2.set(e.subarray(i2, i2 + c), this.pos), this.pos += c, i2 += c, this.pos === o2 && (this.process(n2, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Nt(this), un(e, this), this.finished = true;
    const { buffer: n2, view: r2, blockLen: o2, isLE: s } = this;
    let { pos: i2 } = this;
    n2[i2++] = 128, lt(this.buffer.subarray(i2)), this.padOffset > o2 - i2 && (this.process(r2, 0), i2 = 0);
    for (let l2 = i2; l2 < o2; l2++) n2[l2] = 0;
    cc(r2, o2 - 8, BigInt(this.length * 8), s), this.process(r2, 0);
    const c = ln(e), f4 = this.outputLen;
    if (f4 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = f4 / 4, a = this.get();
    if (u > a.length) throw new Error("_sha2: outputLen bigger than state");
    for (let l2 = 0; l2 < u; l2++) c.setUint32(4 * l2, a[l2], s);
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n2, buffer: r2, length: o2, finished: s, destroyed: i2, pos: c } = this;
    return e.destroyed = i2, e.finished = s, e.length = o2, e.pos = c, o2 % n2 && e.buffer.set(r2), e;
  }
  clone() {
    return this._cloneInto();
  }
};
var Rt = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var X = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
var J = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
var uc = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var $t = new Uint32Array(64);
var lc = class extends qr {
  constructor(e = 32) {
    super(64, e, 8, false), this.A = Rt[0] | 0, this.B = Rt[1] | 0, this.C = Rt[2] | 0, this.D = Rt[3] | 0, this.E = Rt[4] | 0, this.F = Rt[5] | 0, this.G = Rt[6] | 0, this.H = Rt[7] | 0;
  }
  get() {
    const { A: e, B: n2, C: r2, D: o2, E: s, F: i2, G: c, H: f4 } = this;
    return [e, n2, r2, o2, s, i2, c, f4];
  }
  set(e, n2, r2, o2, s, i2, c, f4) {
    this.A = e | 0, this.B = n2 | 0, this.C = r2 | 0, this.D = o2 | 0, this.E = s | 0, this.F = i2 | 0, this.G = c | 0, this.H = f4 | 0;
  }
  process(e, n2) {
    for (let l2 = 0; l2 < 16; l2++, n2 += 4) $t[l2] = e.getUint32(n2, false);
    for (let l2 = 16; l2 < 64; l2++) {
      const d3 = $t[l2 - 15], h3 = $t[l2 - 2], y2 = bt(d3, 7) ^ bt(d3, 18) ^ d3 >>> 3, m2 = bt(h3, 17) ^ bt(h3, 19) ^ h3 >>> 10;
      $t[l2] = m2 + $t[l2 - 7] + y2 + $t[l2 - 16] | 0;
    }
    let { A: r2, B: o2, C: s, D: i2, E: c, F: f4, G: u, H: a } = this;
    for (let l2 = 0; l2 < 64; l2++) {
      const d3 = bt(c, 6) ^ bt(c, 11) ^ bt(c, 25), h3 = a + d3 + fc(c, f4, u) + uc[l2] + $t[l2] | 0, m2 = (bt(r2, 2) ^ bt(r2, 13) ^ bt(r2, 22)) + ac(r2, o2, s) | 0;
      a = u, u = f4, f4 = c, c = i2 + h3 | 0, i2 = s, s = o2, o2 = r2, r2 = h3 + m2 | 0;
    }
    r2 = r2 + this.A | 0, o2 = o2 + this.B | 0, s = s + this.C | 0, i2 = i2 + this.D | 0, c = c + this.E | 0, f4 = f4 + this.F | 0, u = u + this.G | 0, a = a + this.H | 0, this.set(r2, o2, s, i2, c, f4, u, a);
  }
  roundClean() {
    lt($t);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), lt(this.buffer);
  }
};
var Fr = _r(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t) => BigInt(t)));
var dc = Fr[0];
var hc = Fr[1];
var Tt = new Uint32Array(80);
var Ct = new Uint32Array(80);
var dn = class extends qr {
  constructor(e = 64) {
    super(128, e, 16, false), this.Ah = J[0] | 0, this.Al = J[1] | 0, this.Bh = J[2] | 0, this.Bl = J[3] | 0, this.Ch = J[4] | 0, this.Cl = J[5] | 0, this.Dh = J[6] | 0, this.Dl = J[7] | 0, this.Eh = J[8] | 0, this.El = J[9] | 0, this.Fh = J[10] | 0, this.Fl = J[11] | 0, this.Gh = J[12] | 0, this.Gl = J[13] | 0, this.Hh = J[14] | 0, this.Hl = J[15] | 0;
  }
  get() {
    const { Ah: e, Al: n2, Bh: r2, Bl: o2, Ch: s, Cl: i2, Dh: c, Dl: f4, Eh: u, El: a, Fh: l2, Fl: d3, Gh: h3, Gl: y2, Hh: m2, Hl: v } = this;
    return [e, n2, r2, o2, s, i2, c, f4, u, a, l2, d3, h3, y2, m2, v];
  }
  set(e, n2, r2, o2, s, i2, c, f4, u, a, l2, d3, h3, y2, m2, v) {
    this.Ah = e | 0, this.Al = n2 | 0, this.Bh = r2 | 0, this.Bl = o2 | 0, this.Ch = s | 0, this.Cl = i2 | 0, this.Dh = c | 0, this.Dl = f4 | 0, this.Eh = u | 0, this.El = a | 0, this.Fh = l2 | 0, this.Fl = d3 | 0, this.Gh = h3 | 0, this.Gl = y2 | 0, this.Hh = m2 | 0, this.Hl = v | 0;
  }
  process(e, n2) {
    for (let R2 = 0; R2 < 16; R2++, n2 += 4) Tt[R2] = e.getUint32(n2), Ct[R2] = e.getUint32(n2 += 4);
    for (let R2 = 16; R2 < 80; R2++) {
      const Z = Tt[R2 - 15] | 0, H = Ct[R2 - 15] | 0, j = St(Z, H, 1) ^ St(Z, H, 8) ^ Rr(Z, H, 7), L = Ot(Z, H, 1) ^ Ot(Z, H, 8) ^ $r(Z, H, 7), k = Tt[R2 - 2] | 0, O2 = Ct[R2 - 2] | 0, T = St(k, O2, 19) ^ de(k, O2, 61) ^ Rr(k, O2, 6), C4 = Ot(k, O2, 19) ^ he(k, O2, 61) ^ $r(k, O2, 6), _ = qi(L, C4, Ct[R2 - 7], Ct[R2 - 16]), p = Fi(_, j, T, Tt[R2 - 7], Tt[R2 - 16]);
      Tt[R2] = p | 0, Ct[R2] = _ | 0;
    }
    let { Ah: r2, Al: o2, Bh: s, Bl: i2, Ch: c, Cl: f4, Dh: u, Dl: a, Eh: l2, El: d3, Fh: h3, Fl: y2, Gh: m2, Gl: v, Hh: U, Hl: F } = this;
    for (let R2 = 0; R2 < 80; R2++) {
      const Z = St(l2, d3, 14) ^ St(l2, d3, 18) ^ de(l2, d3, 41), H = Ot(l2, d3, 14) ^ Ot(l2, d3, 18) ^ he(l2, d3, 41), j = l2 & h3 ^ ~l2 & m2, L = d3 & y2 ^ ~d3 & v, k = Zi(F, H, L, hc[R2], Ct[R2]), O2 = Gi(k, U, Z, j, dc[R2], Tt[R2]), T = k | 0, C4 = St(r2, o2, 28) ^ de(r2, o2, 34) ^ de(r2, o2, 39), _ = Ot(r2, o2, 28) ^ he(r2, o2, 34) ^ he(r2, o2, 39), p = r2 & s ^ r2 & c ^ s & c, b = o2 & i2 ^ o2 & f4 ^ i2 & f4;
      U = m2 | 0, F = v | 0, m2 = h3 | 0, v = y2 | 0, h3 = l2 | 0, y2 = d3 | 0, { h: l2, l: d3 } = dt(u | 0, a | 0, O2 | 0, T | 0), u = c | 0, a = f4 | 0, c = s | 0, f4 = i2 | 0, s = r2 | 0, i2 = o2 | 0;
      const g = fn(T, _, b);
      r2 = an(g, O2, C4, p), o2 = g | 0;
    }
    ({ h: r2, l: o2 } = dt(this.Ah | 0, this.Al | 0, r2 | 0, o2 | 0)), { h: s, l: i2 } = dt(this.Bh | 0, this.Bl | 0, s | 0, i2 | 0), { h: c, l: f4 } = dt(this.Ch | 0, this.Cl | 0, c | 0, f4 | 0), { h: u, l: a } = dt(this.Dh | 0, this.Dl | 0, u | 0, a | 0), { h: l2, l: d3 } = dt(this.Eh | 0, this.El | 0, l2 | 0, d3 | 0), { h: h3, l: y2 } = dt(this.Fh | 0, this.Fl | 0, h3 | 0, y2 | 0), { h: m2, l: v } = dt(this.Gh | 0, this.Gl | 0, m2 | 0, v | 0), { h: U, l: F } = dt(this.Hh | 0, this.Hl | 0, U | 0, F | 0), this.set(r2, o2, s, i2, c, f4, u, a, l2, d3, h3, y2, m2, v, U, F);
  }
  roundClean() {
    lt(Tt, Ct);
  }
  destroy() {
    lt(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var pc = class extends dn {
  constructor() {
    super(48), this.Ah = X[0] | 0, this.Al = X[1] | 0, this.Bh = X[2] | 0, this.Bl = X[3] | 0, this.Ch = X[4] | 0, this.Cl = X[5] | 0, this.Dh = X[6] | 0, this.Dl = X[7] | 0, this.Eh = X[8] | 0, this.El = X[9] | 0, this.Fh = X[10] | 0, this.Fl = X[11] | 0, this.Gh = X[12] | 0, this.Gl = X[13] | 0, this.Hh = X[14] | 0, this.Hl = X[15] | 0;
  }
};
var Q = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
var gc = class extends dn {
  constructor() {
    super(32), this.Ah = Q[0] | 0, this.Al = Q[1] | 0, this.Bh = Q[2] | 0, this.Bl = Q[3] | 0, this.Ch = Q[4] | 0, this.Cl = Q[5] | 0, this.Dh = Q[6] | 0, this.Dl = Q[7] | 0, this.Eh = Q[8] | 0, this.El = Q[9] | 0, this.Fh = Q[10] | 0, this.Fl = Q[11] | 0, this.Gh = Q[12] | 0, this.Gl = Q[13] | 0, this.Hh = Q[14] | 0, this.Hl = Q[15] | 0;
  }
};
var $e = ge(() => new lc());
var bc = ge(() => new dn());
var yc = ge(() => new pc());
var mc = ge(() => new gc());
var wc = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
var z = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
var S = new Uint32Array(32);
function jt(t, e, n2, r2, o2, s) {
  const i2 = o2[s], c = o2[s + 1];
  let f4 = S[2 * t], u = S[2 * t + 1], a = S[2 * e], l2 = S[2 * e + 1], d3 = S[2 * n2], h3 = S[2 * n2 + 1], y2 = S[2 * r2], m2 = S[2 * r2 + 1], v = fn(f4, a, i2);
  u = an(v, u, l2, c), f4 = v | 0, { Dh: m2, Dl: y2 } = { Dh: m2 ^ u, Dl: y2 ^ f4 }, { Dh: m2, Dl: y2 } = { Dh: Pi(m2, y2), Dl: Hi(m2) }, { h: h3, l: d3 } = dt(h3, d3, m2, y2), { Bh: l2, Bl: a } = { Bh: l2 ^ h3, Bl: a ^ d3 }, { Bh: l2, Bl: a } = { Bh: St(l2, a, 24), Bl: Ot(l2, a, 24) }, S[2 * t] = f4, S[2 * t + 1] = u, S[2 * e] = a, S[2 * e + 1] = l2, S[2 * n2] = d3, S[2 * n2 + 1] = h3, S[2 * r2] = y2, S[2 * r2 + 1] = m2;
}
function Lt(t, e, n2, r2, o2, s) {
  const i2 = o2[s], c = o2[s + 1];
  let f4 = S[2 * t], u = S[2 * t + 1], a = S[2 * e], l2 = S[2 * e + 1], d3 = S[2 * n2], h3 = S[2 * n2 + 1], y2 = S[2 * r2], m2 = S[2 * r2 + 1], v = fn(f4, a, i2);
  u = an(v, u, l2, c), f4 = v | 0, { Dh: m2, Dl: y2 } = { Dh: m2 ^ u, Dl: y2 ^ f4 }, { Dh: m2, Dl: y2 } = { Dh: St(m2, y2, 16), Dl: Ot(m2, y2, 16) }, { h: h3, l: d3 } = dt(h3, d3, m2, y2), { Bh: l2, Bl: a } = { Bh: l2 ^ h3, Bl: a ^ d3 }, { Bh: l2, Bl: a } = { Bh: de(l2, a, 63), Bl: he(l2, a, 63) }, S[2 * t] = f4, S[2 * t + 1] = u, S[2 * e] = a, S[2 * e + 1] = l2, S[2 * n2] = d3, S[2 * n2 + 1] = h3, S[2 * r2] = y2, S[2 * r2 + 1] = m2;
}
function vc(t, e = {}, n2, r2, o2) {
  if (mt(n2), t < 0 || t > n2) throw new Error("outputLen bigger than keyLen");
  const { key: s, salt: i2, personalization: c } = e;
  if (s !== void 0 && (s.length < 1 || s.length > n2)) throw new Error("key length must be undefined or 1.." + n2);
  if (i2 !== void 0 && i2.length !== r2) throw new Error("salt must be undefined or " + r2);
  if (c !== void 0 && c.length !== o2) throw new Error("personalization must be undefined or " + o2);
}
var xc = class extends Re {
  constructor(e, n2) {
    super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, mt(e), mt(n2), this.blockLen = e, this.outputLen = n2, this.buffer = new Uint8Array(e), this.buffer32 = pe(this.buffer);
  }
  update(e) {
    Nt(this), e = pt(e), ht(e);
    const { blockLen: n2, buffer: r2, buffer32: o2 } = this, s = e.length, i2 = e.byteOffset, c = e.buffer;
    for (let f4 = 0; f4 < s; ) {
      this.pos === n2 && (Ut(o2), this.compress(o2, 0, false), Ut(o2), this.pos = 0);
      const u = Math.min(n2 - this.pos, s - f4), a = i2 + f4;
      if (u === n2 && !(a % 4) && f4 + u < s) {
        const l2 = new Uint32Array(c, a, Math.floor((s - f4) / 4));
        Ut(l2);
        for (let d3 = 0; f4 + n2 < s; d3 += o2.length, f4 += n2) this.length += n2, this.compress(l2, d3, false);
        Ut(l2);
        continue;
      }
      r2.set(e.subarray(f4, f4 + u), this.pos), this.pos += u, this.length += u, f4 += u;
    }
    return this;
  }
  digestInto(e) {
    Nt(this), un(e, this);
    const { pos: n2, buffer32: r2 } = this;
    this.finished = true, lt(this.buffer.subarray(n2)), Ut(r2), this.compress(r2, 0, true), Ut(r2);
    const o2 = pe(e);
    this.get().forEach((s, i2) => o2[i2] = wt(s));
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    const { buffer: n2, length: r2, finished: o2, destroyed: s, outputLen: i2, pos: c } = this;
    return e || (e = new this.constructor({ dkLen: i2 })), e.set(...this.get()), e.buffer.set(n2), e.destroyed = s, e.finished = o2, e.length = r2, e.pos = c, e.outputLen = i2, e;
  }
  clone() {
    return this._cloneInto();
  }
};
var Ec = class extends xc {
  constructor(e = {}) {
    const n2 = e.dkLen === void 0 ? 64 : e.dkLen;
    super(128, n2), this.v0l = z[0] | 0, this.v0h = z[1] | 0, this.v1l = z[2] | 0, this.v1h = z[3] | 0, this.v2l = z[4] | 0, this.v2h = z[5] | 0, this.v3l = z[6] | 0, this.v3h = z[7] | 0, this.v4l = z[8] | 0, this.v4h = z[9] | 0, this.v5l = z[10] | 0, this.v5h = z[11] | 0, this.v6l = z[12] | 0, this.v6h = z[13] | 0, this.v7l = z[14] | 0, this.v7h = z[15] | 0, vc(n2, e, 64, 16, 16);
    let { key: r2, personalization: o2, salt: s } = e, i2 = 0;
    if (r2 !== void 0 && (r2 = pt(r2), i2 = r2.length), this.v0l ^= this.outputLen | i2 << 8 | 65536 | 1 << 24, s !== void 0) {
      s = pt(s);
      const c = pe(s);
      this.v4l ^= wt(c[0]), this.v4h ^= wt(c[1]), this.v5l ^= wt(c[2]), this.v5h ^= wt(c[3]);
    }
    if (o2 !== void 0) {
      o2 = pt(o2);
      const c = pe(o2);
      this.v6l ^= wt(c[0]), this.v6h ^= wt(c[1]), this.v7l ^= wt(c[2]), this.v7h ^= wt(c[3]);
    }
    if (r2 !== void 0) {
      const c = new Uint8Array(this.blockLen);
      c.set(r2), this.update(c);
    }
  }
  get() {
    let { v0l: e, v0h: n2, v1l: r2, v1h: o2, v2l: s, v2h: i2, v3l: c, v3h: f4, v4l: u, v4h: a, v5l: l2, v5h: d3, v6l: h3, v6h: y2, v7l: m2, v7h: v } = this;
    return [e, n2, r2, o2, s, i2, c, f4, u, a, l2, d3, h3, y2, m2, v];
  }
  set(e, n2, r2, o2, s, i2, c, f4, u, a, l2, d3, h3, y2, m2, v) {
    this.v0l = e | 0, this.v0h = n2 | 0, this.v1l = r2 | 0, this.v1h = o2 | 0, this.v2l = s | 0, this.v2h = i2 | 0, this.v3l = c | 0, this.v3h = f4 | 0, this.v4l = u | 0, this.v4h = a | 0, this.v5l = l2 | 0, this.v5h = d3 | 0, this.v6l = h3 | 0, this.v6h = y2 | 0, this.v7l = m2 | 0, this.v7h = v | 0;
  }
  compress(e, n2, r2) {
    this.get().forEach((f4, u) => S[u] = f4), S.set(z, 16);
    let { h: o2, l: s } = Ur(BigInt(this.length));
    S[24] = z[8] ^ s, S[25] = z[9] ^ o2, r2 && (S[28] = ~S[28], S[29] = ~S[29]);
    let i2 = 0;
    const c = wc;
    for (let f4 = 0; f4 < 12; f4++) jt(0, 4, 8, 12, e, n2 + 2 * c[i2++]), Lt(0, 4, 8, 12, e, n2 + 2 * c[i2++]), jt(1, 5, 9, 13, e, n2 + 2 * c[i2++]), Lt(1, 5, 9, 13, e, n2 + 2 * c[i2++]), jt(2, 6, 10, 14, e, n2 + 2 * c[i2++]), Lt(2, 6, 10, 14, e, n2 + 2 * c[i2++]), jt(3, 7, 11, 15, e, n2 + 2 * c[i2++]), Lt(3, 7, 11, 15, e, n2 + 2 * c[i2++]), jt(0, 5, 10, 15, e, n2 + 2 * c[i2++]), Lt(0, 5, 10, 15, e, n2 + 2 * c[i2++]), jt(1, 6, 11, 12, e, n2 + 2 * c[i2++]), Lt(1, 6, 11, 12, e, n2 + 2 * c[i2++]), jt(2, 7, 8, 13, e, n2 + 2 * c[i2++]), Lt(2, 7, 8, 13, e, n2 + 2 * c[i2++]), jt(3, 4, 9, 14, e, n2 + 2 * c[i2++]), Lt(3, 4, 9, 14, e, n2 + 2 * c[i2++]);
    this.v0l ^= S[0] ^ S[16], this.v0h ^= S[1] ^ S[17], this.v1l ^= S[2] ^ S[18], this.v1h ^= S[3] ^ S[19], this.v2l ^= S[4] ^ S[20], this.v2h ^= S[5] ^ S[21], this.v3l ^= S[6] ^ S[22], this.v3h ^= S[7] ^ S[23], this.v4l ^= S[8] ^ S[24], this.v4h ^= S[9] ^ S[25], this.v5l ^= S[10] ^ S[26], this.v5h ^= S[11] ^ S[27], this.v6l ^= S[12] ^ S[28], this.v6h ^= S[13] ^ S[29], this.v7l ^= S[14] ^ S[30], this.v7h ^= S[15] ^ S[31], lt(S);
  }
  destroy() {
    this.destroyed = true, lt(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Bc = Wi((t) => new Ec(t));
function lo(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function vn(t) {
  if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
}
function xn(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function ot(t, ...e) {
  if (!lo(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function ho(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function Gc(t, e) {
  ot(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
function Pt(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function Qt(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
function zc(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
var Yc = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Wc(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function En(t) {
  if (typeof t == "string") t = Wc(t);
  else if (lo(t)) t = Bn(t);
  else throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function Xc(t, e) {
  if (e == null || typeof e != "object") throw new Error("options must be defined");
  return Object.assign(t, e);
}
function Jc(t, e) {
  if (t.length !== e.length) return false;
  let n2 = 0;
  for (let r2 = 0; r2 < t.length; r2++) n2 |= t[r2] ^ e[r2];
  return n2 === 0;
}
var Qc = (t, e) => {
  function n2(r2, ...o2) {
    if (ot(r2), !Yc) throw new Error("Non little-endian hardware is not yet supported");
    if (t.nonceLength !== void 0) {
      const a = o2[0];
      if (!a) throw new Error("nonce / iv required");
      t.varSizeNonce ? ot(a) : ot(a, t.nonceLength);
    }
    const s = t.tagLength;
    s && o2[1] !== void 0 && ot(o2[1]);
    const i2 = e(r2, ...o2), c = (a, l2) => {
      if (l2 !== void 0) {
        if (a !== 2) throw new Error("cipher output not supported");
        ot(l2);
      }
    };
    let f4 = false;
    return { encrypt(a, l2) {
      if (f4) throw new Error("cannot encrypt() twice with same key + nonce");
      return f4 = true, ot(a), c(i2.encrypt.length, l2), i2.encrypt(a, l2);
    }, decrypt(a, l2) {
      if (ot(a), s && a.length < s) throw new Error("invalid ciphertext length: smaller than tagLength=" + s);
      return c(i2.decrypt.length, l2), i2.decrypt(a, l2);
    } };
  }
  return Object.assign(n2, t), n2;
};
function po(t, e, n2 = true) {
  if (e === void 0) return new Uint8Array(t);
  if (e.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e.length);
  if (n2 && !ef(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function go(t, e, n2, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r2);
  const o2 = BigInt(32), s = BigInt(4294967295), i2 = Number(n2 >> o2 & s), c = Number(n2 & s), f4 = r2 ? 4 : 0, u = r2 ? 0 : 4;
  t.setUint32(e + f4, i2, r2), t.setUint32(e + u, c, r2);
}
function tf(t, e, n2) {
  vn(n2);
  const r2 = new Uint8Array(16), o2 = zc(r2);
  return go(o2, 0, BigInt(e), n2), go(o2, 8, BigInt(t), n2), r2;
}
function ef(t) {
  return t.byteOffset % 4 === 0;
}
function Bn(t) {
  return Uint8Array.from(t);
}
var bo = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0)));
var nf = bo("expand 16-byte k");
var rf = bo("expand 32-byte k");
var of = Pt(nf);
var sf = Pt(rf);
function K(t, e) {
  return t << e | t >>> 32 - e;
}
function An(t) {
  return t.byteOffset % 4 === 0;
}
var Le = 64;
var cf = 16;
var yo = 2 ** 32 - 1;
var mo = new Uint32Array();
function ff(t, e, n2, r2, o2, s, i2, c) {
  const f4 = o2.length, u = new Uint8Array(Le), a = Pt(u), l2 = An(o2) && An(s), d3 = l2 ? Pt(o2) : mo, h3 = l2 ? Pt(s) : mo;
  for (let y2 = 0; y2 < f4; i2++) {
    if (t(e, n2, r2, a, i2, c), i2 >= yo) throw new Error("arx: counter overflow");
    const m2 = Math.min(Le, f4 - y2);
    if (l2 && m2 === Le) {
      const v = y2 / 4;
      if (y2 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let U = 0, F; U < cf; U++) F = v + U, h3[F] = d3[F] ^ a[U];
      y2 += Le;
      continue;
    }
    for (let v = 0, U; v < m2; v++) U = y2 + v, s[U] = o2[U] ^ u[v];
    y2 += m2;
  }
}
function af(t, e) {
  const { allowShortKeys: n2, extendNonceFn: r2, counterLength: o2, counterRight: s, rounds: i2 } = Xc({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e);
  if (typeof t != "function") throw new Error("core must be a function");
  return xn(o2), xn(i2), vn(s), vn(n2), (c, f4, u, a, l2 = 0) => {
    ot(c), ot(f4), ot(u);
    const d3 = u.length;
    if (a === void 0 && (a = new Uint8Array(d3)), ot(a), xn(l2), l2 < 0 || l2 >= yo) throw new Error("arx: counter overflow");
    if (a.length < d3) throw new Error(`arx: output (${a.length}) is shorter than data (${d3})`);
    const h3 = [];
    let y2 = c.length, m2, v;
    if (y2 === 32) h3.push(m2 = Bn(c)), v = sf;
    else if (y2 === 16 && n2) m2 = new Uint8Array(32), m2.set(c), m2.set(c, 16), v = of, h3.push(m2);
    else throw new Error(`arx: invalid 32-byte key, got length=${y2}`);
    An(f4) || h3.push(f4 = Bn(f4));
    const U = Pt(m2);
    if (r2) {
      if (f4.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r2(v, U, Pt(f4.subarray(0, 16)), U), f4 = f4.subarray(16);
    }
    const F = 16 - o2;
    if (F !== f4.length) throw new Error(`arx: nonce must be ${F} or 16 bytes`);
    if (F !== 12) {
      const Z = new Uint8Array(12);
      Z.set(f4, s ? 0 : 12 - f4.length), f4 = Z, h3.push(f4);
    }
    const R2 = Pt(f4);
    return ff(t, v, U, R2, u, a, l2, i2), Qt(...h3), a;
  };
}
var W = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;
var uf = class {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e = En(e), ot(e, 32);
    const n2 = W(e, 0), r2 = W(e, 2), o2 = W(e, 4), s = W(e, 6), i2 = W(e, 8), c = W(e, 10), f4 = W(e, 12), u = W(e, 14);
    this.r[0] = n2 & 8191, this.r[1] = (n2 >>> 13 | r2 << 3) & 8191, this.r[2] = (r2 >>> 10 | o2 << 6) & 7939, this.r[3] = (o2 >>> 7 | s << 9) & 8191, this.r[4] = (s >>> 4 | i2 << 12) & 255, this.r[5] = i2 >>> 1 & 8190, this.r[6] = (i2 >>> 14 | c << 2) & 8191, this.r[7] = (c >>> 11 | f4 << 5) & 8065, this.r[8] = (f4 >>> 8 | u << 8) & 8191, this.r[9] = u >>> 5 & 127;
    for (let a = 0; a < 8; a++) this.pad[a] = W(e, 16 + 2 * a);
  }
  process(e, n2, r2 = false) {
    const o2 = r2 ? 0 : 2048, { h: s, r: i2 } = this, c = i2[0], f4 = i2[1], u = i2[2], a = i2[3], l2 = i2[4], d3 = i2[5], h3 = i2[6], y2 = i2[7], m2 = i2[8], v = i2[9], U = W(e, n2 + 0), F = W(e, n2 + 2), R2 = W(e, n2 + 4), Z = W(e, n2 + 6), H = W(e, n2 + 8), j = W(e, n2 + 10), L = W(e, n2 + 12), k = W(e, n2 + 14);
    let O2 = s[0] + (U & 8191), T = s[1] + ((U >>> 13 | F << 3) & 8191), C4 = s[2] + ((F >>> 10 | R2 << 6) & 8191), _ = s[3] + ((R2 >>> 7 | Z << 9) & 8191), p = s[4] + ((Z >>> 4 | H << 12) & 8191), b = s[5] + (H >>> 1 & 8191), g = s[6] + ((H >>> 14 | j << 2) & 8191), x2 = s[7] + ((j >>> 11 | L << 5) & 8191), E = s[8] + ((L >>> 8 | k << 8) & 8191), A2 = s[9] + (k >>> 5 | o2), w2 = 0, B = w2 + O2 * c + T * (5 * v) + C4 * (5 * m2) + _ * (5 * y2) + p * (5 * h3);
    w2 = B >>> 13, B &= 8191, B += b * (5 * d3) + g * (5 * l2) + x2 * (5 * a) + E * (5 * u) + A2 * (5 * f4), w2 += B >>> 13, B &= 8191;
    let I2 = w2 + O2 * f4 + T * c + C4 * (5 * v) + _ * (5 * m2) + p * (5 * y2);
    w2 = I2 >>> 13, I2 &= 8191, I2 += b * (5 * h3) + g * (5 * d3) + x2 * (5 * l2) + E * (5 * a) + A2 * (5 * u), w2 += I2 >>> 13, I2 &= 8191;
    let N2 = w2 + O2 * u + T * f4 + C4 * c + _ * (5 * v) + p * (5 * m2);
    w2 = N2 >>> 13, N2 &= 8191, N2 += b * (5 * y2) + g * (5 * h3) + x2 * (5 * d3) + E * (5 * l2) + A2 * (5 * a), w2 += N2 >>> 13, N2 &= 8191;
    let D2 = w2 + O2 * a + T * u + C4 * f4 + _ * c + p * (5 * v);
    w2 = D2 >>> 13, D2 &= 8191, D2 += b * (5 * m2) + g * (5 * y2) + x2 * (5 * h3) + E * (5 * d3) + A2 * (5 * l2), w2 += D2 >>> 13, D2 &= 8191;
    let P2 = w2 + O2 * l2 + T * a + C4 * u + _ * f4 + p * c;
    w2 = P2 >>> 13, P2 &= 8191, P2 += b * (5 * v) + g * (5 * m2) + x2 * (5 * y2) + E * (5 * h3) + A2 * (5 * d3), w2 += P2 >>> 13, P2 &= 8191;
    let $2 = w2 + O2 * d3 + T * l2 + C4 * a + _ * u + p * f4;
    w2 = $2 >>> 13, $2 &= 8191, $2 += b * c + g * (5 * v) + x2 * (5 * m2) + E * (5 * y2) + A2 * (5 * h3), w2 += $2 >>> 13, $2 &= 8191;
    let V2 = w2 + O2 * h3 + T * d3 + C4 * l2 + _ * a + p * u;
    w2 = V2 >>> 13, V2 &= 8191, V2 += b * f4 + g * c + x2 * (5 * v) + E * (5 * m2) + A2 * (5 * y2), w2 += V2 >>> 13, V2 &= 8191;
    let q2 = w2 + O2 * y2 + T * h3 + C4 * d3 + _ * l2 + p * a;
    w2 = q2 >>> 13, q2 &= 8191, q2 += b * u + g * f4 + x2 * c + E * (5 * v) + A2 * (5 * m2), w2 += q2 >>> 13, q2 &= 8191;
    let G2 = w2 + O2 * m2 + T * y2 + C4 * h3 + _ * d3 + p * l2;
    w2 = G2 >>> 13, G2 &= 8191, G2 += b * a + g * u + x2 * f4 + E * c + A2 * (5 * v), w2 += G2 >>> 13, G2 &= 8191;
    let M2 = w2 + O2 * v + T * m2 + C4 * y2 + _ * h3 + p * d3;
    w2 = M2 >>> 13, M2 &= 8191, M2 += b * l2 + g * a + x2 * u + E * f4 + A2 * c, w2 += M2 >>> 13, M2 &= 8191, w2 = (w2 << 2) + w2 | 0, w2 = w2 + B | 0, B = w2 & 8191, w2 = w2 >>> 13, I2 += w2, s[0] = B, s[1] = I2, s[2] = N2, s[3] = D2, s[4] = P2, s[5] = $2, s[6] = V2, s[7] = q2, s[8] = G2, s[9] = M2;
  }
  finalize() {
    const { h: e, pad: n2 } = this, r2 = new Uint16Array(10);
    let o2 = e[1] >>> 13;
    e[1] &= 8191;
    for (let c = 2; c < 10; c++) e[c] += o2, o2 = e[c] >>> 13, e[c] &= 8191;
    e[0] += o2 * 5, o2 = e[0] >>> 13, e[0] &= 8191, e[1] += o2, o2 = e[1] >>> 13, e[1] &= 8191, e[2] += o2, r2[0] = e[0] + 5, o2 = r2[0] >>> 13, r2[0] &= 8191;
    for (let c = 1; c < 10; c++) r2[c] = e[c] + o2, o2 = r2[c] >>> 13, r2[c] &= 8191;
    r2[9] -= 8192;
    let s = (o2 ^ 1) - 1;
    for (let c = 0; c < 10; c++) r2[c] &= s;
    s = ~s;
    for (let c = 0; c < 10; c++) e[c] = e[c] & s | r2[c];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let i2 = e[0] + n2[0];
    e[0] = i2 & 65535;
    for (let c = 1; c < 8; c++) i2 = (e[c] + n2[c] | 0) + (i2 >>> 16) | 0, e[c] = i2 & 65535;
    Qt(r2);
  }
  update(e) {
    ho(this), e = En(e), ot(e);
    const { buffer: n2, blockLen: r2 } = this, o2 = e.length;
    for (let s = 0; s < o2; ) {
      const i2 = Math.min(r2 - this.pos, o2 - s);
      if (i2 === r2) {
        for (; r2 <= o2 - s; s += r2) this.process(e, s);
        continue;
      }
      n2.set(e.subarray(s, s + i2), this.pos), this.pos += i2, s += i2, this.pos === r2 && (this.process(n2, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Qt(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    ho(this), Gc(e, this), this.finished = true;
    const { buffer: n2, h: r2 } = this;
    let { pos: o2 } = this;
    if (o2) {
      for (n2[o2++] = 1; o2 < 16; o2++) n2[o2] = 0;
      this.process(n2, 0, true);
    }
    this.finalize();
    let s = 0;
    for (let i2 = 0; i2 < 8; i2++) e[s++] = r2[i2] >>> 0, e[s++] = r2[i2] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
};
function lf(t) {
  const e = (r2, o2) => t(o2).update(En(r2)).digest(), n2 = t(new Uint8Array(32));
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = (r2) => t(r2), e;
}
var df = lf((t) => new uf(t));
function hf(t, e, n2, r2, o2, s = 20) {
  let i2 = t[0], c = t[1], f4 = t[2], u = t[3], a = e[0], l2 = e[1], d3 = e[2], h3 = e[3], y2 = e[4], m2 = e[5], v = e[6], U = e[7], F = o2, R2 = n2[0], Z = n2[1], H = n2[2], j = i2, L = c, k = f4, O2 = u, T = a, C4 = l2, _ = d3, p = h3, b = y2, g = m2, x2 = v, E = U, A2 = F, w2 = R2, B = Z, I2 = H;
  for (let D2 = 0; D2 < s; D2 += 2) j = j + T | 0, A2 = K(A2 ^ j, 16), b = b + A2 | 0, T = K(T ^ b, 12), j = j + T | 0, A2 = K(A2 ^ j, 8), b = b + A2 | 0, T = K(T ^ b, 7), L = L + C4 | 0, w2 = K(w2 ^ L, 16), g = g + w2 | 0, C4 = K(C4 ^ g, 12), L = L + C4 | 0, w2 = K(w2 ^ L, 8), g = g + w2 | 0, C4 = K(C4 ^ g, 7), k = k + _ | 0, B = K(B ^ k, 16), x2 = x2 + B | 0, _ = K(_ ^ x2, 12), k = k + _ | 0, B = K(B ^ k, 8), x2 = x2 + B | 0, _ = K(_ ^ x2, 7), O2 = O2 + p | 0, I2 = K(I2 ^ O2, 16), E = E + I2 | 0, p = K(p ^ E, 12), O2 = O2 + p | 0, I2 = K(I2 ^ O2, 8), E = E + I2 | 0, p = K(p ^ E, 7), j = j + C4 | 0, I2 = K(I2 ^ j, 16), x2 = x2 + I2 | 0, C4 = K(C4 ^ x2, 12), j = j + C4 | 0, I2 = K(I2 ^ j, 8), x2 = x2 + I2 | 0, C4 = K(C4 ^ x2, 7), L = L + _ | 0, A2 = K(A2 ^ L, 16), E = E + A2 | 0, _ = K(_ ^ E, 12), L = L + _ | 0, A2 = K(A2 ^ L, 8), E = E + A2 | 0, _ = K(_ ^ E, 7), k = k + p | 0, w2 = K(w2 ^ k, 16), b = b + w2 | 0, p = K(p ^ b, 12), k = k + p | 0, w2 = K(w2 ^ k, 8), b = b + w2 | 0, p = K(p ^ b, 7), O2 = O2 + T | 0, B = K(B ^ O2, 16), g = g + B | 0, T = K(T ^ g, 12), O2 = O2 + T | 0, B = K(B ^ O2, 8), g = g + B | 0, T = K(T ^ g, 7);
  let N2 = 0;
  r2[N2++] = i2 + j | 0, r2[N2++] = c + L | 0, r2[N2++] = f4 + k | 0, r2[N2++] = u + O2 | 0, r2[N2++] = a + T | 0, r2[N2++] = l2 + C4 | 0, r2[N2++] = d3 + _ | 0, r2[N2++] = h3 + p | 0, r2[N2++] = y2 + b | 0, r2[N2++] = m2 + g | 0, r2[N2++] = v + x2 | 0, r2[N2++] = U + E | 0, r2[N2++] = F + A2 | 0, r2[N2++] = R2 + w2 | 0, r2[N2++] = Z + B | 0, r2[N2++] = H + I2 | 0;
}
var pf = af(hf, { counterRight: false, counterLength: 4, allowShortKeys: false });
var gf = new Uint8Array(16);
var wo = (t, e) => {
  t.update(e);
  const n2 = e.length % 16;
  n2 && t.update(gf.subarray(n2));
};
var bf = new Uint8Array(32);
function vo(t, e, n2, r2, o2) {
  const s = t(e, n2, bf), i2 = df.create(s);
  o2 && wo(i2, o2), wo(i2, r2);
  const c = tf(r2.length, o2 ? o2.length : 0, true);
  i2.update(c);
  const f4 = i2.digest();
  return Qt(s, c), f4;
}
var yf = (t) => (e, n2, r2) => ({ encrypt(s, i2) {
  const c = s.length;
  i2 = po(c + 16, i2, false), i2.set(s);
  const f4 = i2.subarray(0, -16);
  t(e, n2, f4, f4, 1);
  const u = vo(t, e, n2, f4, r2);
  return i2.set(u, c), Qt(u), i2;
}, decrypt(s, i2) {
  i2 = po(s.length - 16, i2, false);
  const c = s.subarray(0, -16), f4 = s.subarray(-16), u = vo(t, e, n2, c, r2);
  if (!Jc(f4, u)) throw new Error("invalid tag");
  return i2.set(s.subarray(0, -16)), t(e, n2, i2, i2, 1), Qt(u), i2;
} });
var xo = Qc({ blockSize: 64, nonceLength: 12, tagLength: 16 }, yf(pf));
var Eo = class extends Re {
  constructor(e, n2) {
    super(), this.finished = false, this.destroyed = false, Ue(e);
    const r2 = pt(n2);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o2 = this.blockLen, s = new Uint8Array(o2);
    s.set(r2.length > o2 ? e.create().update(r2).digest() : r2);
    for (let i2 = 0; i2 < s.length; i2++) s[i2] ^= 54;
    this.iHash.update(s), this.oHash = e.create();
    for (let i2 = 0; i2 < s.length; i2++) s[i2] ^= 106;
    this.oHash.update(s), lt(s);
  }
  update(e) {
    return Nt(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Nt(this), ht(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n2, iHash: r2, finished: o2, destroyed: s, blockLen: i2, outputLen: c } = this;
    return e = e, e.finished = o2, e.destroyed = s, e.blockLen = i2, e.outputLen = c, e.oHash = n2._cloneInto(e.oHash), e.iHash = r2._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var ke = (t, e, n2) => new Eo(t, e).update(n2).digest();
ke.create = (t, e) => new Eo(t, e);
var In = Uint8Array.from([0]);
var Bo = Uint8Array.of();
var Sn = BigInt(0);
var On = BigInt(1);
function He(t, e = "") {
  if (typeof t != "boolean") {
    const n2 = e && `"${e}"`;
    throw new Error(n2 + "expected boolean, got type=" + typeof t);
  }
  return t;
}
function Kt(t, e, n2 = "") {
  const r2 = Ne(t), o2 = t?.length, s = e !== void 0;
  if (!r2 || s && o2 !== e) {
    const i2 = n2 && `"${n2}" `, c = s ? ` of length ${e}` : "", f4 = r2 ? `length=${o2}` : `type=${typeof t}`;
    throw new Error(i2 + "expected Uint8Array" + c + ", got " + f4);
  }
  return t;
}
function De(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function Ao(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? Sn : BigInt("0x" + t);
}
function Ve(t) {
  return Ao(Jt(t));
}
function Me(t) {
  return ht(t), Ao(Jt(Uint8Array.from(t).reverse()));
}
function Nn(t, e) {
  return _e(t.toString(16).padStart(e * 2, "0"));
}
function Un(t, e) {
  return Nn(t, e).reverse();
}
function tt(t, e, n2) {
  let r2;
  if (typeof e == "string") try {
    r2 = _e(e);
  } catch (s) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + s);
  }
  else if (Ne(e)) r2 = Uint8Array.from(e);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o2 = r2.length;
  if (typeof n2 == "number" && o2 !== n2) throw new Error(t + " of length " + n2 + " expected, got " + o2);
  return r2;
}
var _n = (t) => typeof t == "bigint" && Sn <= t;
function xf(t, e, n2) {
  return _n(t) && _n(e) && _n(n2) && e <= t && t < n2;
}
function Rn(t, e, n2, r2) {
  if (!xf(e, n2, r2)) throw new Error("expected valid " + t + ": " + n2 + " <= n < " + r2 + ", got " + e);
}
function Io(t) {
  let e;
  for (e = 0; t > Sn; t >>= On, e += 1) ;
  return e;
}
var ye = (t) => (On << BigInt(t)) - On;
function Ef(t, e, n2) {
  if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
  if (typeof n2 != "function") throw new Error("hmacFn must be a function");
  const r2 = (h3) => new Uint8Array(h3), o2 = (h3) => Uint8Array.of(h3);
  let s = r2(t), i2 = r2(t), c = 0;
  const f4 = () => {
    s.fill(1), i2.fill(0), c = 0;
  }, u = (...h3) => n2(i2, s, ...h3), a = (h3 = r2(0)) => {
    i2 = u(o2(0), h3), s = u(), h3.length !== 0 && (i2 = u(o2(1), h3), s = u());
  }, l2 = () => {
    if (c++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let h3 = 0;
    const y2 = [];
    for (; h3 < e; ) {
      s = u();
      const m2 = s.slice();
      y2.push(m2), h3 += s.length;
    }
    return _t(...y2);
  };
  return (h3, y2) => {
    f4(), a(h3);
    let m2;
    for (; !(m2 = y2(l2())); ) a();
    return f4(), m2;
  };
}
function Ke(t, e, n2 = {}) {
  if (!t || typeof t != "object") throw new Error("expected valid options object");
  function r2(o2, s, i2) {
    const c = t[o2];
    if (i2 && c === void 0) return;
    const f4 = typeof c;
    if (f4 !== s || c === null) throw new Error(`param "${o2}" is invalid: expected ${s}, got ${f4}`);
  }
  Object.entries(e).forEach(([o2, s]) => r2(o2, s, false)), Object.entries(n2).forEach(([o2, s]) => r2(o2, s, true));
}
function So(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n2, ...r2) => {
    const o2 = e.get(n2);
    if (o2 !== void 0) return o2;
    const s = t(n2, ...r2);
    return e.set(n2, s), s;
  };
}
var st = BigInt(0);
var nt = BigInt(1);
var qt = BigInt(2);
var Oo = BigInt(3);
var No = BigInt(4);
var Uo = BigInt(5);
var Bf = BigInt(7);
var _o = BigInt(8);
var Af = BigInt(9);
var Ro = BigInt(16);
function ct(t, e) {
  const n2 = t % e;
  return n2 >= st ? n2 : e + n2;
}
function gt(t, e, n2) {
  let r2 = t;
  for (; e-- > st; ) r2 *= r2, r2 %= n2;
  return r2;
}
function $o(t, e) {
  if (t === st) throw new Error("invert: expected non-zero number");
  if (e <= st) throw new Error("invert: expected positive modulus, got " + e);
  let n2 = ct(t, e), r2 = e, o2 = st, s = nt;
  for (; n2 !== st; ) {
    const c = r2 / n2, f4 = r2 % n2, u = o2 - s * c;
    r2 = n2, n2 = f4, o2 = s, s = u;
  }
  if (r2 !== nt) throw new Error("invert: does not exist");
  return ct(o2, e);
}
function $n(t, e, n2) {
  if (!t.eql(t.sqr(e), n2)) throw new Error("Cannot find square root");
}
function To(t, e) {
  const n2 = (t.ORDER + nt) / No, r2 = t.pow(e, n2);
  return $n(t, r2, e), r2;
}
function If(t, e) {
  const n2 = (t.ORDER - Uo) / _o, r2 = t.mul(e, qt), o2 = t.pow(r2, n2), s = t.mul(e, o2), i2 = t.mul(t.mul(s, qt), o2), c = t.mul(s, t.sub(i2, t.ONE));
  return $n(t, c, e), c;
}
function Sf(t) {
  const e = Ht(t), n2 = Co(t), r2 = n2(e, e.neg(e.ONE)), o2 = n2(e, r2), s = n2(e, e.neg(r2)), i2 = (t + Bf) / Ro;
  return (c, f4) => {
    let u = c.pow(f4, i2), a = c.mul(u, r2);
    const l2 = c.mul(u, o2), d3 = c.mul(u, s), h3 = c.eql(c.sqr(a), f4), y2 = c.eql(c.sqr(l2), f4);
    u = c.cmov(u, a, h3), a = c.cmov(d3, l2, y2);
    const m2 = c.eql(c.sqr(a), f4), v = c.cmov(u, a, m2);
    return $n(c, v, f4), v;
  };
}
function Co(t) {
  if (t < Oo) throw new Error("sqrt is not defined for small field");
  let e = t - nt, n2 = 0;
  for (; e % qt === st; ) e /= qt, n2++;
  let r2 = qt;
  const o2 = Ht(t);
  for (; Lo(o2, r2) === 1; ) if (r2++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (n2 === 1) return To;
  let s = o2.pow(r2, e);
  const i2 = (e + nt) / qt;
  return function(f4, u) {
    if (f4.is0(u)) return u;
    if (Lo(f4, u) !== 1) throw new Error("Cannot find square root");
    let a = n2, l2 = f4.mul(f4.ONE, s), d3 = f4.pow(u, e), h3 = f4.pow(u, i2);
    for (; !f4.eql(d3, f4.ONE); ) {
      if (f4.is0(d3)) return f4.ZERO;
      let y2 = 1, m2 = f4.sqr(d3);
      for (; !f4.eql(m2, f4.ONE); ) if (y2++, m2 = f4.sqr(m2), y2 === a) throw new Error("Cannot find square root");
      const v = nt << BigInt(a - y2 - 1), U = f4.pow(l2, v);
      a = y2, l2 = f4.sqr(U), d3 = f4.mul(d3, l2), h3 = f4.mul(h3, U);
    }
    return h3;
  };
}
function Of(t) {
  return t % No === Oo ? To : t % _o === Uo ? If : t % Ro === Af ? Sf(t) : Co(t);
}
var Nf = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function Uf(t) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, n2 = Nf.reduce((r2, o2) => (r2[o2] = "function", r2), e);
  return Ke(t, n2), t;
}
function _f(t, e, n2) {
  if (n2 < st) throw new Error("invalid exponent, negatives unsupported");
  if (n2 === st) return t.ONE;
  if (n2 === nt) return e;
  let r2 = t.ONE, o2 = e;
  for (; n2 > st; ) n2 & nt && (r2 = t.mul(r2, o2)), o2 = t.sqr(o2), n2 >>= nt;
  return r2;
}
function jo(t, e, n2 = false) {
  const r2 = new Array(e.length).fill(n2 ? t.ZERO : void 0), o2 = e.reduce((i2, c, f4) => t.is0(c) ? i2 : (r2[f4] = i2, t.mul(i2, c)), t.ONE), s = t.inv(o2);
  return e.reduceRight((i2, c, f4) => t.is0(c) ? i2 : (r2[f4] = t.mul(i2, r2[f4]), t.mul(i2, c)), s), r2;
}
function Lo(t, e) {
  const n2 = (t.ORDER - nt) / qt, r2 = t.pow(e, n2), o2 = t.eql(r2, t.ONE), s = t.eql(r2, t.ZERO), i2 = t.eql(r2, t.neg(t.ONE));
  if (!o2 && !s && !i2) throw new Error("invalid Legendre symbol result");
  return o2 ? 1 : s ? 0 : -1;
}
function ko(t, e) {
  e !== void 0 && mt(e);
  const n2 = e !== void 0 ? e : t.toString(2).length, r2 = Math.ceil(n2 / 8);
  return { nBitLength: n2, nByteLength: r2 };
}
function Ht(t, e, n2 = false, r2 = {}) {
  if (t <= st) throw new Error("invalid field: expected ORDER > 0, got " + t);
  let o2, s, i2 = false, c;
  if (typeof e == "object" && e != null) {
    if (r2.sqrt || n2) throw new Error("cannot specify opts in two arguments");
    const d3 = e;
    d3.BITS && (o2 = d3.BITS), d3.sqrt && (s = d3.sqrt), typeof d3.isLE == "boolean" && (n2 = d3.isLE), typeof d3.modFromBytes == "boolean" && (i2 = d3.modFromBytes), c = d3.allowedLengths;
  } else typeof e == "number" && (o2 = e), r2.sqrt && (s = r2.sqrt);
  const { nBitLength: f4, nByteLength: u } = ko(t, o2);
  if (u > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a;
  const l2 = Object.freeze({ ORDER: t, isLE: n2, BITS: f4, BYTES: u, MASK: ye(f4), ZERO: st, ONE: nt, allowedLengths: c, create: (d3) => ct(d3, t), isValid: (d3) => {
    if (typeof d3 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof d3);
    return st <= d3 && d3 < t;
  }, is0: (d3) => d3 === st, isValidNot0: (d3) => !l2.is0(d3) && l2.isValid(d3), isOdd: (d3) => (d3 & nt) === nt, neg: (d3) => ct(-d3, t), eql: (d3, h3) => d3 === h3, sqr: (d3) => ct(d3 * d3, t), add: (d3, h3) => ct(d3 + h3, t), sub: (d3, h3) => ct(d3 - h3, t), mul: (d3, h3) => ct(d3 * h3, t), pow: (d3, h3) => _f(l2, d3, h3), div: (d3, h3) => ct(d3 * $o(h3, t), t), sqrN: (d3) => d3 * d3, addN: (d3, h3) => d3 + h3, subN: (d3, h3) => d3 - h3, mulN: (d3, h3) => d3 * h3, inv: (d3) => $o(d3, t), sqrt: s || ((d3) => (a || (a = Of(t)), a(l2, d3))), toBytes: (d3) => n2 ? Un(d3, u) : Nn(d3, u), fromBytes: (d3, h3 = true) => {
    if (c) {
      if (!c.includes(d3.length) || d3.length > u) throw new Error("Field.fromBytes: expected " + c + " bytes, got " + d3.length);
      const m2 = new Uint8Array(u);
      m2.set(d3, n2 ? 0 : m2.length - d3.length), d3 = m2;
    }
    if (d3.length !== u) throw new Error("Field.fromBytes: expected " + u + " bytes, got " + d3.length);
    let y2 = n2 ? Me(d3) : Ve(d3);
    if (i2 && (y2 = ct(y2, t)), !h3 && !l2.isValid(y2)) throw new Error("invalid field element: outside of range 0..ORDER");
    return y2;
  }, invertBatch: (d3) => jo(l2, d3), cmov: (d3, h3, y2) => y2 ? h3 : d3 });
  return Object.freeze(l2);
}
function Po(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function Ho(t) {
  const e = Po(t);
  return e + Math.ceil(e / 2);
}
function Rf(t, e, n2 = false) {
  const r2 = t.length, o2 = Po(e), s = Ho(e);
  if (r2 < 16 || r2 < s || r2 > 1024) throw new Error("expected " + s + "-1024 bytes of input, got " + r2);
  const i2 = n2 ? Me(t) : Ve(t), c = ct(i2, e - nt) + nt;
  return n2 ? Un(c, o2) : Nn(c, o2);
}
var te = BigInt(0);
var Ft = BigInt(1);
function qe(t, e) {
  const n2 = e.negate();
  return t ? n2 : e;
}
function Tn(t, e) {
  const n2 = jo(t.Fp, e.map((r2) => r2.Z));
  return e.map((r2, o2) => t.fromAffine(r2.toAffine(n2[o2])));
}
function Do(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function Cn(t, e) {
  Do(t, e);
  const n2 = Math.ceil(e / t) + 1, r2 = 2 ** (t - 1), o2 = 2 ** t, s = ye(t), i2 = BigInt(t);
  return { windows: n2, windowSize: r2, mask: s, maxNumber: o2, shiftBy: i2 };
}
function Vo(t, e, n2) {
  const { windowSize: r2, mask: o2, maxNumber: s, shiftBy: i2 } = n2;
  let c = Number(t & o2), f4 = t >> i2;
  c > r2 && (c -= s, f4 += Ft);
  const u = e * r2, a = u + Math.abs(c) - 1, l2 = c === 0, d3 = c < 0, h3 = e % 2 !== 0;
  return { nextN: f4, offset: a, isZero: l2, isNeg: d3, isNegF: h3, offsetF: u };
}
function $f(t, e) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n2, r2) => {
    if (!(n2 instanceof e)) throw new Error("invalid point at index " + r2);
  });
}
function Tf(t, e) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n2, r2) => {
    if (!e.isValid(n2)) throw new Error("invalid scalar at index " + r2);
  });
}
var jn = /* @__PURE__ */ new WeakMap();
var Mo = /* @__PURE__ */ new WeakMap();
function Ln(t) {
  return Mo.get(t) || 1;
}
function Ko(t) {
  if (t !== te) throw new Error("invalid wNAF");
}
var Cf = class {
  constructor(e, n2) {
    this.BASE = e.BASE, this.ZERO = e.ZERO, this.Fn = e.Fn, this.bits = n2;
  }
  _unsafeLadder(e, n2, r2 = this.ZERO) {
    let o2 = e;
    for (; n2 > te; ) n2 & Ft && (r2 = r2.add(o2)), o2 = o2.double(), n2 >>= Ft;
    return r2;
  }
  precomputeWindow(e, n2) {
    const { windows: r2, windowSize: o2 } = Cn(n2, this.bits), s = [];
    let i2 = e, c = i2;
    for (let f4 = 0; f4 < r2; f4++) {
      c = i2, s.push(c);
      for (let u = 1; u < o2; u++) c = c.add(i2), s.push(c);
      i2 = c.double();
    }
    return s;
  }
  wNAF(e, n2, r2) {
    if (!this.Fn.isValid(r2)) throw new Error("invalid scalar");
    let o2 = this.ZERO, s = this.BASE;
    const i2 = Cn(e, this.bits);
    for (let c = 0; c < i2.windows; c++) {
      const { nextN: f4, offset: u, isZero: a, isNeg: l2, isNegF: d3, offsetF: h3 } = Vo(r2, c, i2);
      r2 = f4, a ? s = s.add(qe(d3, n2[h3])) : o2 = o2.add(qe(l2, n2[u]));
    }
    return Ko(r2), { p: o2, f: s };
  }
  wNAFUnsafe(e, n2, r2, o2 = this.ZERO) {
    const s = Cn(e, this.bits);
    for (let i2 = 0; i2 < s.windows && r2 !== te; i2++) {
      const { nextN: c, offset: f4, isZero: u, isNeg: a } = Vo(r2, i2, s);
      if (r2 = c, !u) {
        const l2 = n2[f4];
        o2 = o2.add(a ? l2.negate() : l2);
      }
    }
    return Ko(r2), o2;
  }
  getPrecomputes(e, n2, r2) {
    let o2 = jn.get(n2);
    return o2 || (o2 = this.precomputeWindow(n2, e), e !== 1 && (typeof r2 == "function" && (o2 = r2(o2)), jn.set(n2, o2))), o2;
  }
  cached(e, n2, r2) {
    const o2 = Ln(e);
    return this.wNAF(o2, this.getPrecomputes(o2, e, r2), n2);
  }
  unsafe(e, n2, r2, o2) {
    const s = Ln(e);
    return s === 1 ? this._unsafeLadder(e, n2, o2) : this.wNAFUnsafe(s, this.getPrecomputes(s, e, r2), n2, o2);
  }
  createCache(e, n2) {
    Do(n2, this.bits), Mo.set(e, n2), jn.delete(e);
  }
  hasCache(e) {
    return Ln(e) !== 1;
  }
};
function jf(t, e, n2, r2) {
  let o2 = e, s = t.ZERO, i2 = t.ZERO;
  for (; n2 > te || r2 > te; ) n2 & Ft && (s = s.add(o2)), r2 & Ft && (i2 = i2.add(o2)), o2 = o2.double(), n2 >>= Ft, r2 >>= Ft;
  return { p1: s, p2: i2 };
}
function Lf(t, e, n2, r2) {
  $f(n2, t), Tf(r2, e);
  const o2 = n2.length, s = r2.length;
  if (o2 !== s) throw new Error("arrays of points and scalars must have equal length");
  const i2 = t.ZERO, c = Io(BigInt(o2));
  let f4 = 1;
  c > 12 ? f4 = c - 3 : c > 4 ? f4 = c - 2 : c > 0 && (f4 = 2);
  const u = ye(f4), a = new Array(Number(u) + 1).fill(i2), l2 = Math.floor((e.BITS - 1) / f4) * f4;
  let d3 = i2;
  for (let h3 = l2; h3 >= 0; h3 -= f4) {
    a.fill(i2);
    for (let m2 = 0; m2 < s; m2++) {
      const v = r2[m2], U = Number(v >> BigInt(h3) & u);
      a[U] = a[U].add(n2[m2]);
    }
    let y2 = i2;
    for (let m2 = a.length - 1, v = i2; m2 > 0; m2--) v = v.add(a[m2]), y2 = y2.add(v);
    if (d3 = d3.add(y2), h3 !== 0) for (let m2 = 0; m2 < f4; m2++) d3 = d3.double();
  }
  return d3;
}
function qo(t, e, n2) {
  if (e) {
    if (e.ORDER !== t) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return Uf(e), e;
  } else return Ht(t, { isLE: n2 });
}
function kf(t, e, n2 = {}, r2) {
  if (r2 === void 0 && (r2 = t === "edwards"), !e || typeof e != "object") throw new Error(`expected valid ${t} CURVE object`);
  for (const f4 of ["p", "n", "h"]) {
    const u = e[f4];
    if (!(typeof u == "bigint" && u > te)) throw new Error(`CURVE.${f4} must be positive bigint`);
  }
  const o2 = qo(e.p, n2.Fp, r2), s = qo(e.n, n2.Fn, r2), c = ["Gx", "Gy", "a", t === "weierstrass" ? "b" : "d"];
  for (const f4 of c) if (!o2.isValid(e[f4])) throw new Error(`CURVE.${f4} must be valid field element of CURVE.Fp`);
  return e = Object.freeze(Object.assign({}, e)), { CURVE: e, Fp: o2, Fn: s };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8), kr("HashToScalar-");
var me = BigInt(0);
var ee = BigInt(1);
var Fe = BigInt(2);
function Pf(t) {
  return Ke(t, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...t });
}
function Hf(t) {
  const e = Pf(t), { P: n2, type: r2, adjustScalarBytes: o2, powPminus2: s, randomBytes: i2 } = e, c = r2 === "x25519";
  if (!c && r2 !== "x448") throw new Error("invalid type");
  const f4 = i2 || Mt, u = c ? 255 : 448, a = c ? 32 : 56, l2 = BigInt(c ? 9 : 5), d3 = BigInt(c ? 121665 : 39081), h3 = c ? Fe ** BigInt(254) : Fe ** BigInt(447), y2 = c ? BigInt(8) * Fe ** BigInt(251) - ee : BigInt(4) * Fe ** BigInt(445) - ee, m2 = h3 + y2 + ee, v = (p) => ct(p, n2), U = F(l2);
  function F(p) {
    return Un(v(p), a);
  }
  function R2(p) {
    const b = tt("u coordinate", p, a);
    return c && (b[31] &= 127), v(Me(b));
  }
  function Z(p) {
    return Me(o2(tt("scalar", p, a)));
  }
  function H(p, b) {
    const g = k(R2(b), Z(p));
    if (g === me) throw new Error("invalid private or public key received");
    return F(g);
  }
  function j(p) {
    return H(p, U);
  }
  function L(p, b, g) {
    const x2 = v(p * (b - g));
    return b = v(b - x2), g = v(g + x2), { x_2: b, x_3: g };
  }
  function k(p, b) {
    Rn("u", p, me, n2), Rn("scalar", b, h3, m2);
    const g = b, x2 = p;
    let E = ee, A2 = me, w2 = p, B = ee, I2 = me;
    for (let D2 = BigInt(u - 1); D2 >= me; D2--) {
      const P2 = g >> D2 & ee;
      I2 ^= P2, { x_2: E, x_3: w2 } = L(I2, E, w2), { x_2: A2, x_3: B } = L(I2, A2, B), I2 = P2;
      const $2 = E + A2, V2 = v($2 * $2), q2 = E - A2, G2 = v(q2 * q2), M2 = V2 - G2, Y3 = w2 + B, Yt2 = w2 - B, ce = v(Yt2 * $2), fe = v(Y3 * q2), Qn = ce + fe, tr = ce - fe;
      w2 = v(Qn * Qn), B = v(x2 * v(tr * tr)), E = v(V2 * G2), A2 = v(M2 * (V2 + v(d3 * M2)));
    }
    ({ x_2: E, x_3: w2 } = L(I2, E, w2)), { x_2: A2, x_3: B } = L(I2, A2, B);
    const N2 = s(A2);
    return v(E * N2);
  }
  const O2 = { secretKey: a, publicKey: a, seed: a }, T = (p = f4(a)) => (ht(p, O2.seed), p);
  function C4(p) {
    const b = T(p);
    return { secretKey: b, publicKey: j(b) };
  }
  return { keygen: C4, getSharedSecret: (p, b) => H(p, b), getPublicKey: (p) => j(p), scalarMult: H, scalarMultBase: j, utils: { randomSecretKey: T, randomPrivateKey: T }, GuBytes: U.slice(), lengths: O2 };
}
var Df = BigInt(1);
var Fo = BigInt(2);
var Vf = BigInt(3);
var Mf = BigInt(5);
var Kf = BigInt(8);
var Zo = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
var qf = { p: Zo, n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: Kf, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") };
function Ff(t) {
  const e = BigInt(10), n2 = BigInt(20), r2 = BigInt(40), o2 = BigInt(80), s = Zo, c = t * t % s * t % s, f4 = gt(c, Fo, s) * c % s, u = gt(f4, Df, s) * t % s, a = gt(u, Mf, s) * u % s, l2 = gt(a, e, s) * a % s, d3 = gt(l2, n2, s) * l2 % s, h3 = gt(d3, r2, s) * d3 % s, y2 = gt(h3, o2, s) * h3 % s, m2 = gt(y2, o2, s) * h3 % s, v = gt(m2, e, s) * a % s;
  return { pow_p_5_8: gt(v, Fo, s) * t % s, b2: c };
}
function Zf(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
var Gf = Ht(qf.p, { isLE: true });
var kn = (() => {
  const t = Gf.ORDER;
  return Hf({ P: t, type: "x25519", powPminus2: (e) => {
    const { pow_p_5_8: n2, b2: r2 } = Ff(e);
    return ct(gt(n2, Vf, t) * r2, t);
  }, adjustScalarBytes: Zf });
})();
var Go = (t, e) => (t + (t >= 0 ? e : -e) / zo) / e;
function zf(t, e, n2) {
  const [[r2, o2], [s, i2]] = e, c = Go(i2 * t, n2), f4 = Go(-o2 * t, n2);
  let u = t - c * r2 - f4 * s, a = -c * o2 - f4 * i2;
  const l2 = u < Et, d3 = a < Et;
  l2 && (u = -u), d3 && (a = -a);
  const h3 = ye(Math.ceil(Io(n2) / 2)) + ne;
  if (u < Et || u >= h3 || a < Et || a >= h3) throw new Error("splitScalar (endomorphism): failed, k=" + t);
  return { k1neg: l2, k1: u, k2neg: d3, k2: a };
}
function Pn(t) {
  if (!["compact", "recovered", "der"].includes(t)) throw new Error('Signature format must be "compact", "recovered", or "der"');
  return t;
}
function Hn(t, e) {
  const n2 = {};
  for (let r2 of Object.keys(e)) n2[r2] = t[r2] === void 0 ? e[r2] : t[r2];
  return He(n2.lowS, "lowS"), He(n2.prehash, "prehash"), n2.format !== void 0 && Pn(n2.format), n2;
}
var Yf = class extends Error {
  constructor(e = "") {
    super(e);
  }
};
var xt = { Err: Yf, _tlv: { encode: (t, e) => {
  const { Err: n2 } = xt;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length & 1) throw new n2("tlv.encode: unpadded data");
  const r2 = e.length / 2, o2 = De(r2);
  if (o2.length / 2 & 128) throw new n2("tlv.encode: long form length too big");
  const s = r2 > 127 ? De(o2.length / 2 | 128) : "";
  return De(t) + s + o2 + e;
}, decode(t, e) {
  const { Err: n2 } = xt;
  let r2 = 0;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length < 2 || e[r2++] !== t) throw new n2("tlv.decode: wrong tlv");
  const o2 = e[r2++], s = !!(o2 & 128);
  let i2 = 0;
  if (!s) i2 = o2;
  else {
    const f4 = o2 & 127;
    if (!f4) throw new n2("tlv.decode(long): indefinite length not supported");
    if (f4 > 4) throw new n2("tlv.decode(long): byte length is too big");
    const u = e.subarray(r2, r2 + f4);
    if (u.length !== f4) throw new n2("tlv.decode: length bytes not complete");
    if (u[0] === 0) throw new n2("tlv.decode(long): zero leftmost byte");
    for (const a of u) i2 = i2 << 8 | a;
    if (r2 += f4, i2 < 128) throw new n2("tlv.decode(long): not minimal encoding");
  }
  const c = e.subarray(r2, r2 + i2);
  if (c.length !== i2) throw new n2("tlv.decode: wrong value length");
  return { v: c, l: e.subarray(r2 + i2) };
} }, _int: { encode(t) {
  const { Err: e } = xt;
  if (t < Et) throw new e("integer: negative integers are not allowed");
  let n2 = De(t);
  if (Number.parseInt(n2[0], 16) & 8 && (n2 = "00" + n2), n2.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
  return n2;
}, decode(t) {
  const { Err: e } = xt;
  if (t[0] & 128) throw new e("invalid signature integer: negative");
  if (t[0] === 0 && !(t[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
  return Ve(t);
} }, toSig(t) {
  const { Err: e, _int: n2, _tlv: r2 } = xt, o2 = tt("signature", t), { v: s, l: i2 } = r2.decode(48, o2);
  if (i2.length) throw new e("invalid signature: left bytes after parsing");
  const { v: c, l: f4 } = r2.decode(2, s), { v: u, l: a } = r2.decode(2, f4);
  if (a.length) throw new e("invalid signature: left bytes after parsing");
  return { r: n2.decode(c), s: n2.decode(u) };
}, hexFromSig(t) {
  const { _tlv: e, _int: n2 } = xt, r2 = e.encode(2, n2.encode(t.r)), o2 = e.encode(2, n2.encode(t.s)), s = r2 + o2;
  return e.encode(48, s);
} };
var Et = BigInt(0);
var ne = BigInt(1);
var zo = BigInt(2);
var Ze = BigInt(3);
var Wf = BigInt(4);
function re(t, e) {
  const { BYTES: n2 } = t;
  let r2;
  if (typeof e == "bigint") r2 = e;
  else {
    let o2 = tt("private key", e);
    try {
      r2 = t.fromBytes(o2);
    } catch {
      throw new Error(`invalid private key: expected ui8a of size ${n2}, got ${typeof e}`);
    }
  }
  if (!t.isValidNot0(r2)) throw new Error("invalid private key: out of range [1..N-1]");
  return r2;
}
function Xf(t, e = {}) {
  const n2 = kf("weierstrass", t, e), { Fp: r2, Fn: o2 } = n2;
  let s = n2.CURVE;
  const { h: i2, n: c } = s;
  Ke(e, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: f4 } = e;
  if (f4 && (!r2.is0(s.a) || typeof f4.beta != "bigint" || !Array.isArray(f4.basises))) throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const u = Wo(r2, o2);
  function a() {
    if (!r2.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function l2(_, p, b) {
    const { x: g, y: x2 } = p.toAffine(), E = r2.toBytes(g);
    if (He(b, "isCompressed"), b) {
      a();
      const A2 = !r2.isOdd(x2);
      return _t(Yo(A2), E);
    } else return _t(Uint8Array.of(4), E, r2.toBytes(x2));
  }
  function d3(_) {
    Kt(_, void 0, "Point");
    const { publicKey: p, publicKeyUncompressed: b } = u, g = _.length, x2 = _[0], E = _.subarray(1);
    if (g === p && (x2 === 2 || x2 === 3)) {
      const A2 = r2.fromBytes(E);
      if (!r2.isValid(A2)) throw new Error("bad point: is not on curve, wrong x");
      const w2 = m2(A2);
      let B;
      try {
        B = r2.sqrt(w2);
      } catch (D2) {
        const P2 = D2 instanceof Error ? ": " + D2.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + P2);
      }
      a();
      const I2 = r2.isOdd(B);
      return (x2 & 1) === 1 !== I2 && (B = r2.neg(B)), { x: A2, y: B };
    } else if (g === b && x2 === 4) {
      const A2 = r2.BYTES, w2 = r2.fromBytes(E.subarray(0, A2)), B = r2.fromBytes(E.subarray(A2, A2 * 2));
      if (!v(w2, B)) throw new Error("bad point: is not on curve");
      return { x: w2, y: B };
    } else throw new Error(`bad point: got length ${g}, expected compressed=${p} or uncompressed=${b}`);
  }
  const h3 = e.toBytes || l2, y2 = e.fromBytes || d3;
  function m2(_) {
    const p = r2.sqr(_), b = r2.mul(p, _);
    return r2.add(r2.add(b, r2.mul(_, s.a)), s.b);
  }
  function v(_, p) {
    const b = r2.sqr(p), g = m2(_);
    return r2.eql(b, g);
  }
  if (!v(s.Gx, s.Gy)) throw new Error("bad curve params: generator point");
  const U = r2.mul(r2.pow(s.a, Ze), Wf), F = r2.mul(r2.sqr(s.b), BigInt(27));
  if (r2.is0(r2.add(U, F))) throw new Error("bad curve params: a or b");
  function R2(_, p, b = false) {
    if (!r2.isValid(p) || b && r2.is0(p)) throw new Error(`bad point coordinate ${_}`);
    return p;
  }
  function Z(_) {
    if (!(_ instanceof O2)) throw new Error("ProjectivePoint expected");
  }
  function H(_) {
    if (!f4 || !f4.basises) throw new Error("no endo");
    return zf(_, f4.basises, o2.ORDER);
  }
  const j = So((_, p) => {
    const { X: b, Y: g, Z: x2 } = _;
    if (r2.eql(x2, r2.ONE)) return { x: b, y: g };
    const E = _.is0();
    p == null && (p = E ? r2.ONE : r2.inv(x2));
    const A2 = r2.mul(b, p), w2 = r2.mul(g, p), B = r2.mul(x2, p);
    if (E) return { x: r2.ZERO, y: r2.ZERO };
    if (!r2.eql(B, r2.ONE)) throw new Error("invZ was invalid");
    return { x: A2, y: w2 };
  }), L = So((_) => {
    if (_.is0()) {
      if (e.allowInfinityPoint && !r2.is0(_.Y)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: p, y: b } = _.toAffine();
    if (!r2.isValid(p) || !r2.isValid(b)) throw new Error("bad point: x or y not field elements");
    if (!v(p, b)) throw new Error("bad point: equation left != right");
    if (!_.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function k(_, p, b, g, x2) {
    return b = new O2(r2.mul(b.X, _), b.Y, b.Z), p = qe(g, p), b = qe(x2, b), p.add(b);
  }
  class O2 {
    constructor(p, b, g) {
      this.X = R2("x", p), this.Y = R2("y", b, true), this.Z = R2("z", g), Object.freeze(this);
    }
    static CURVE() {
      return s;
    }
    static fromAffine(p) {
      const { x: b, y: g } = p || {};
      if (!p || !r2.isValid(b) || !r2.isValid(g)) throw new Error("invalid affine point");
      if (p instanceof O2) throw new Error("projective point not allowed");
      return r2.is0(b) && r2.is0(g) ? O2.ZERO : new O2(b, g, r2.ONE);
    }
    static fromBytes(p) {
      const b = O2.fromAffine(y2(Kt(p, void 0, "point")));
      return b.assertValidity(), b;
    }
    static fromHex(p) {
      return O2.fromBytes(tt("pointHex", p));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(p = 8, b = true) {
      return C4.createCache(this, p), b || this.multiply(Ze), this;
    }
    assertValidity() {
      L(this);
    }
    hasEvenY() {
      const { y: p } = this.toAffine();
      if (!r2.isOdd) throw new Error("Field doesn't support isOdd");
      return !r2.isOdd(p);
    }
    equals(p) {
      Z(p);
      const { X: b, Y: g, Z: x2 } = this, { X: E, Y: A2, Z: w2 } = p, B = r2.eql(r2.mul(b, w2), r2.mul(E, x2)), I2 = r2.eql(r2.mul(g, w2), r2.mul(A2, x2));
      return B && I2;
    }
    negate() {
      return new O2(this.X, r2.neg(this.Y), this.Z);
    }
    double() {
      const { a: p, b } = s, g = r2.mul(b, Ze), { X: x2, Y: E, Z: A2 } = this;
      let w2 = r2.ZERO, B = r2.ZERO, I2 = r2.ZERO, N2 = r2.mul(x2, x2), D2 = r2.mul(E, E), P2 = r2.mul(A2, A2), $2 = r2.mul(x2, E);
      return $2 = r2.add($2, $2), I2 = r2.mul(x2, A2), I2 = r2.add(I2, I2), w2 = r2.mul(p, I2), B = r2.mul(g, P2), B = r2.add(w2, B), w2 = r2.sub(D2, B), B = r2.add(D2, B), B = r2.mul(w2, B), w2 = r2.mul($2, w2), I2 = r2.mul(g, I2), P2 = r2.mul(p, P2), $2 = r2.sub(N2, P2), $2 = r2.mul(p, $2), $2 = r2.add($2, I2), I2 = r2.add(N2, N2), N2 = r2.add(I2, N2), N2 = r2.add(N2, P2), N2 = r2.mul(N2, $2), B = r2.add(B, N2), P2 = r2.mul(E, A2), P2 = r2.add(P2, P2), N2 = r2.mul(P2, $2), w2 = r2.sub(w2, N2), I2 = r2.mul(P2, D2), I2 = r2.add(I2, I2), I2 = r2.add(I2, I2), new O2(w2, B, I2);
    }
    add(p) {
      Z(p);
      const { X: b, Y: g, Z: x2 } = this, { X: E, Y: A2, Z: w2 } = p;
      let B = r2.ZERO, I2 = r2.ZERO, N2 = r2.ZERO;
      const D2 = s.a, P2 = r2.mul(s.b, Ze);
      let $2 = r2.mul(b, E), V2 = r2.mul(g, A2), q2 = r2.mul(x2, w2), G2 = r2.add(b, g), M2 = r2.add(E, A2);
      G2 = r2.mul(G2, M2), M2 = r2.add($2, V2), G2 = r2.sub(G2, M2), M2 = r2.add(b, x2);
      let Y3 = r2.add(E, w2);
      return M2 = r2.mul(M2, Y3), Y3 = r2.add($2, q2), M2 = r2.sub(M2, Y3), Y3 = r2.add(g, x2), B = r2.add(A2, w2), Y3 = r2.mul(Y3, B), B = r2.add(V2, q2), Y3 = r2.sub(Y3, B), N2 = r2.mul(D2, M2), B = r2.mul(P2, q2), N2 = r2.add(B, N2), B = r2.sub(V2, N2), N2 = r2.add(V2, N2), I2 = r2.mul(B, N2), V2 = r2.add($2, $2), V2 = r2.add(V2, $2), q2 = r2.mul(D2, q2), M2 = r2.mul(P2, M2), V2 = r2.add(V2, q2), q2 = r2.sub($2, q2), q2 = r2.mul(D2, q2), M2 = r2.add(M2, q2), $2 = r2.mul(V2, M2), I2 = r2.add(I2, $2), $2 = r2.mul(Y3, M2), B = r2.mul(G2, B), B = r2.sub(B, $2), $2 = r2.mul(G2, V2), N2 = r2.mul(Y3, N2), N2 = r2.add(N2, $2), new O2(B, I2, N2);
    }
    subtract(p) {
      return this.add(p.negate());
    }
    is0() {
      return this.equals(O2.ZERO);
    }
    multiply(p) {
      const { endo: b } = e;
      if (!o2.isValidNot0(p)) throw new Error("invalid scalar: out of range");
      let g, x2;
      const E = (A2) => C4.cached(this, A2, (w2) => Tn(O2, w2));
      if (b) {
        const { k1neg: A2, k1: w2, k2neg: B, k2: I2 } = H(p), { p: N2, f: D2 } = E(w2), { p: P2, f: $2 } = E(I2);
        x2 = D2.add($2), g = k(b.beta, N2, P2, A2, B);
      } else {
        const { p: A2, f: w2 } = E(p);
        g = A2, x2 = w2;
      }
      return Tn(O2, [g, x2])[0];
    }
    multiplyUnsafe(p) {
      const { endo: b } = e, g = this;
      if (!o2.isValid(p)) throw new Error("invalid scalar: out of range");
      if (p === Et || g.is0()) return O2.ZERO;
      if (p === ne) return g;
      if (C4.hasCache(this)) return this.multiply(p);
      if (b) {
        const { k1neg: x2, k1: E, k2neg: A2, k2: w2 } = H(p), { p1: B, p2: I2 } = jf(O2, g, E, w2);
        return k(b.beta, B, I2, x2, A2);
      } else return C4.unsafe(g, p);
    }
    multiplyAndAddUnsafe(p, b, g) {
      const x2 = this.multiplyUnsafe(b).add(p.multiplyUnsafe(g));
      return x2.is0() ? void 0 : x2;
    }
    toAffine(p) {
      return j(this, p);
    }
    isTorsionFree() {
      const { isTorsionFree: p } = e;
      return i2 === ne ? true : p ? p(O2, this) : C4.unsafe(this, c).is0();
    }
    clearCofactor() {
      const { clearCofactor: p } = e;
      return i2 === ne ? this : p ? p(O2, this) : this.multiplyUnsafe(i2);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(i2).is0();
    }
    toBytes(p = true) {
      return He(p, "isCompressed"), this.assertValidity(), h3(O2, this, p);
    }
    toHex(p = true) {
      return Jt(this.toBytes(p));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(p = true) {
      return this.toBytes(p);
    }
    _setWindowSize(p) {
      this.precompute(p);
    }
    static normalizeZ(p) {
      return Tn(O2, p);
    }
    static msm(p, b) {
      return Lf(O2, o2, p, b);
    }
    static fromPrivateKey(p) {
      return O2.BASE.multiply(re(o2, p));
    }
  }
  O2.BASE = new O2(s.Gx, s.Gy, r2.ONE), O2.ZERO = new O2(r2.ZERO, r2.ONE, r2.ZERO), O2.Fp = r2, O2.Fn = o2;
  const T = o2.BITS, C4 = new Cf(O2, e.endo ? Math.ceil(T / 2) : T);
  return O2.BASE.precompute(8), O2;
}
function Yo(t) {
  return Uint8Array.of(t ? 2 : 3);
}
function Wo(t, e) {
  return { secretKey: e.BYTES, publicKey: 1 + t.BYTES, publicKeyUncompressed: 1 + 2 * t.BYTES, publicKeyHasPrefix: true, signature: 2 * e.BYTES };
}
function Jf(t, e = {}) {
  const { Fn: n2 } = t, r2 = e.randomBytes || Mt, o2 = Object.assign(Wo(t.Fp, n2), { seed: Ho(n2.ORDER) });
  function s(h3) {
    try {
      return !!re(n2, h3);
    } catch {
      return false;
    }
  }
  function i2(h3, y2) {
    const { publicKey: m2, publicKeyUncompressed: v } = o2;
    try {
      const U = h3.length;
      return y2 === true && U !== m2 || y2 === false && U !== v ? false : !!t.fromBytes(h3);
    } catch {
      return false;
    }
  }
  function c(h3 = r2(o2.seed)) {
    return Rf(Kt(h3, o2.seed, "seed"), n2.ORDER);
  }
  function f4(h3, y2 = true) {
    return t.BASE.multiply(re(n2, h3)).toBytes(y2);
  }
  function u(h3) {
    const y2 = c(h3);
    return { secretKey: y2, publicKey: f4(y2) };
  }
  function a(h3) {
    if (typeof h3 == "bigint") return false;
    if (h3 instanceof t) return true;
    const { secretKey: y2, publicKey: m2, publicKeyUncompressed: v } = o2;
    if (n2.allowedLengths || y2 === m2) return;
    const U = tt("key", h3).length;
    return U === m2 || U === v;
  }
  function l2(h3, y2, m2 = true) {
    if (a(h3) === true) throw new Error("first arg must be private key");
    if (a(y2) === false) throw new Error("second arg must be public key");
    const v = re(n2, h3);
    return t.fromHex(y2).multiply(v).toBytes(m2);
  }
  return Object.freeze({ getPublicKey: f4, getSharedSecret: l2, keygen: u, Point: t, utils: { isValidSecretKey: s, isValidPublicKey: i2, randomSecretKey: c, isValidPrivateKey: s, randomPrivateKey: c, normPrivateKeyToScalar: (h3) => re(n2, h3), precompute(h3 = 8, y2 = t.BASE) {
    return y2.precompute(h3, false);
  } }, lengths: o2 });
}
function Qf(t, e, n2 = {}) {
  Ue(e), Ke(n2, {}, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const r2 = n2.randomBytes || Mt, o2 = n2.hmac || ((b, ...g) => ke(e, b, _t(...g))), { Fp: s, Fn: i2 } = t, { ORDER: c, BITS: f4 } = i2, { keygen: u, getPublicKey: a, getSharedSecret: l2, utils: d3, lengths: h3 } = Jf(t, n2), y2 = { prehash: false, lowS: typeof n2.lowS == "boolean" ? n2.lowS : false, format: void 0, extraEntropy: false }, m2 = "compact";
  function v(b) {
    const g = c >> ne;
    return b > g;
  }
  function U(b, g) {
    if (!i2.isValidNot0(g)) throw new Error(`invalid signature ${b}: out of range 1..Point.Fn.ORDER`);
    return g;
  }
  function F(b, g) {
    Pn(g);
    const x2 = h3.signature, E = g === "compact" ? x2 : g === "recovered" ? x2 + 1 : void 0;
    return Kt(b, E, `${g} signature`);
  }
  class R2 {
    constructor(g, x2, E) {
      this.r = U("r", g), this.s = U("s", x2), E != null && (this.recovery = E), Object.freeze(this);
    }
    static fromBytes(g, x2 = m2) {
      F(g, x2);
      let E;
      if (x2 === "der") {
        const { r: I2, s: N2 } = xt.toSig(Kt(g));
        return new R2(I2, N2);
      }
      x2 === "recovered" && (E = g[0], x2 = "compact", g = g.subarray(1));
      const A2 = i2.BYTES, w2 = g.subarray(0, A2), B = g.subarray(A2, A2 * 2);
      return new R2(i2.fromBytes(w2), i2.fromBytes(B), E);
    }
    static fromHex(g, x2) {
      return this.fromBytes(_e(g), x2);
    }
    addRecoveryBit(g) {
      return new R2(this.r, this.s, g);
    }
    recoverPublicKey(g) {
      const x2 = s.ORDER, { r: E, s: A2, recovery: w2 } = this;
      if (w2 == null || ![0, 1, 2, 3].includes(w2)) throw new Error("recovery id invalid");
      if (c * zo < x2 && w2 > 1) throw new Error("recovery id is ambiguous for h>1 curve");
      const I2 = w2 === 2 || w2 === 3 ? E + c : E;
      if (!s.isValid(I2)) throw new Error("recovery id 2 or 3 invalid");
      const N2 = s.toBytes(I2), D2 = t.fromBytes(_t(Yo((w2 & 1) === 0), N2)), P2 = i2.inv(I2), $2 = H(tt("msgHash", g)), V2 = i2.create(-$2 * P2), q2 = i2.create(A2 * P2), G2 = t.BASE.multiplyUnsafe(V2).add(D2.multiplyUnsafe(q2));
      if (G2.is0()) throw new Error("point at infinify");
      return G2.assertValidity(), G2;
    }
    hasHighS() {
      return v(this.s);
    }
    toBytes(g = m2) {
      if (Pn(g), g === "der") return _e(xt.hexFromSig(this));
      const x2 = i2.toBytes(this.r), E = i2.toBytes(this.s);
      if (g === "recovered") {
        if (this.recovery == null) throw new Error("recovery bit must be present");
        return _t(Uint8Array.of(this.recovery), x2, E);
      }
      return _t(x2, E);
    }
    toHex(g) {
      return Jt(this.toBytes(g));
    }
    assertValidity() {
    }
    static fromCompact(g) {
      return R2.fromBytes(tt("sig", g), "compact");
    }
    static fromDER(g) {
      return R2.fromBytes(tt("sig", g), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new R2(this.r, i2.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return Jt(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return Jt(this.toBytes("compact"));
    }
  }
  const Z = n2.bits2int || function(g) {
    if (g.length > 8192) throw new Error("input is too large");
    const x2 = Ve(g), E = g.length * 8 - f4;
    return E > 0 ? x2 >> BigInt(E) : x2;
  }, H = n2.bits2int_modN || function(g) {
    return i2.create(Z(g));
  }, j = ye(f4);
  function L(b) {
    return Rn("num < 2^" + f4, b, Et, j), i2.toBytes(b);
  }
  function k(b, g) {
    return Kt(b, void 0, "message"), g ? Kt(e(b), void 0, "prehashed message") : b;
  }
  function O2(b, g, x2) {
    if (["recovered", "canonical"].some((V2) => V2 in x2)) throw new Error("sign() legacy options not supported");
    const { lowS: E, prehash: A2, extraEntropy: w2 } = Hn(x2, y2);
    b = k(b, A2);
    const B = H(b), I2 = re(i2, g), N2 = [L(I2), L(B)];
    if (w2 != null && w2 !== false) {
      const V2 = w2 === true ? r2(h3.secretKey) : w2;
      N2.push(tt("extraEntropy", V2));
    }
    const D2 = _t(...N2), P2 = B;
    function $2(V2) {
      const q2 = Z(V2);
      if (!i2.isValidNot0(q2)) return;
      const G2 = i2.inv(q2), M2 = t.BASE.multiply(q2).toAffine(), Y3 = i2.create(M2.x);
      if (Y3 === Et) return;
      const Yt2 = i2.create(G2 * i2.create(P2 + Y3 * I2));
      if (Yt2 === Et) return;
      let ce = (M2.x === Y3 ? 0 : 2) | Number(M2.y & ne), fe = Yt2;
      return E && v(Yt2) && (fe = i2.neg(Yt2), ce ^= 1), new R2(Y3, fe, ce);
    }
    return { seed: D2, k2sig: $2 };
  }
  function T(b, g, x2 = {}) {
    b = tt("message", b);
    const { seed: E, k2sig: A2 } = O2(b, g, x2);
    return Ef(e.outputLen, i2.BYTES, o2)(E, A2);
  }
  function C4(b) {
    let g;
    const x2 = typeof b == "string" || Ne(b), E = !x2 && b !== null && typeof b == "object" && typeof b.r == "bigint" && typeof b.s == "bigint";
    if (!x2 && !E) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    if (E) g = new R2(b.r, b.s);
    else if (x2) {
      try {
        g = R2.fromBytes(tt("sig", b), "der");
      } catch (A2) {
        if (!(A2 instanceof xt.Err)) throw A2;
      }
      if (!g) try {
        g = R2.fromBytes(tt("sig", b), "compact");
      } catch {
        return false;
      }
    }
    return g || false;
  }
  function _(b, g, x2, E = {}) {
    const { lowS: A2, prehash: w2, format: B } = Hn(E, y2);
    if (x2 = tt("publicKey", x2), g = k(tt("message", g), w2), "strict" in E) throw new Error("options.strict was renamed to lowS");
    const I2 = B === void 0 ? C4(b) : R2.fromBytes(tt("sig", b), B);
    if (I2 === false) return false;
    try {
      const N2 = t.fromBytes(x2);
      if (A2 && I2.hasHighS()) return false;
      const { r: D2, s: P2 } = I2, $2 = H(g), V2 = i2.inv(P2), q2 = i2.create($2 * V2), G2 = i2.create(D2 * V2), M2 = t.BASE.multiplyUnsafe(q2).add(N2.multiplyUnsafe(G2));
      return M2.is0() ? false : i2.create(M2.x) === D2;
    } catch {
      return false;
    }
  }
  function p(b, g, x2 = {}) {
    const { prehash: E } = Hn(x2, y2);
    return g = k(g, E), R2.fromBytes(b, "recovered").recoverPublicKey(g).toBytes();
  }
  return Object.freeze({ keygen: u, getPublicKey: a, getSharedSecret: l2, utils: d3, lengths: h3, Point: t, sign: T, verify: _, recoverPublicKey: p, Signature: R2, hash: e });
}
function ta(t) {
  const e = { a: t.a, b: t.b, p: t.Fp.ORDER, n: t.n, h: t.h, Gx: t.Gx, Gy: t.Gy }, n2 = t.Fp;
  let r2 = t.allowedPrivateKeyLengths ? Array.from(new Set(t.allowedPrivateKeyLengths.map((i2) => Math.ceil(i2 / 2)))) : void 0;
  const o2 = Ht(e.n, { BITS: t.nBitLength, allowedLengths: r2, modFromBytes: t.wrapPrivateKey }), s = { Fp: n2, Fn: o2, allowInfinityPoint: t.allowInfinityPoint, endo: t.endo, isTorsionFree: t.isTorsionFree, clearCofactor: t.clearCofactor, fromBytes: t.fromBytes, toBytes: t.toBytes };
  return { CURVE: e, curveOpts: s };
}
function ea(t) {
  const { CURVE: e, curveOpts: n2 } = ta(t), r2 = { hmac: t.hmac, randomBytes: t.randomBytes, lowS: t.lowS, bits2int: t.bits2int, bits2int_modN: t.bits2int_modN };
  return { CURVE: e, curveOpts: n2, hash: t.hash, ecdsaOpts: r2 };
}
function na(t, e) {
  const n2 = e.Point;
  return Object.assign({}, e, { ProjectivePoint: n2, CURVE: Object.assign({}, t, ko(n2.Fn.ORDER, n2.Fn.BITS)) });
}
function ra(t) {
  const { CURVE: e, curveOpts: n2, hash: r2, ecdsaOpts: o2 } = ea(t), s = Xf(e, n2), i2 = Qf(s, r2, o2);
  return na(t, i2);
}
function Dn(t, e) {
  const n2 = (r2) => ra({ ...t, hash: r2 });
  return { ...n2(e), create: n2 };
}
var Xo = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") };
var Jo = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") };
var Qo = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") };
var oa = Ht(Xo.p);
var sa = Ht(Jo.p);
var ia = Ht(Qo.p);
var ca = Dn({ ...Xo, Fp: oa, lowS: false }, $e);
Dn({ ...Jo, Fp: sa, lowS: false }, yc), Dn({ ...Qo, Fp: ia, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, bc);

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/core/dist/index.js
var import_window_getters2 = __toESM(require_cjs2());
var Ue2 = "wc";
var ge2 = "core";
var W2 = `${Ue2}@2:${ge2}:`;
var Qs = import_time2.FIVE_SECONDS * 1e3;
var Yt = "https://verify.walletconnect.org";
var be2 = Yt;
var Jt2 = `${be2}/v3`;
function cr(r2, e) {
  if (r2.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i2 = 0; i2 < t.length; i2++) t[i2] = 255;
  for (var s = 0; s < r2.length; s++) {
    var n2 = r2.charAt(s), o2 = n2.charCodeAt(0);
    if (t[o2] !== 255) throw new TypeError(n2 + " is ambiguous");
    t[o2] = s;
  }
  var a = r2.length, c = r2.charAt(0), h3 = Math.log(a) / Math.log(256), l2 = Math.log(256) / Math.log(a);
  function g(u) {
    if (u instanceof Uint8Array || (ArrayBuffer.isView(u) ? u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength) : Array.isArray(u) && (u = Uint8Array.from(u))), !(u instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u.length === 0) return "";
    for (var m2 = 0, D2 = 0, w2 = 0, E = u.length; w2 !== E && u[w2] === 0; ) w2++, m2++;
    for (var L = (E - w2) * l2 + 1 >>> 0, I2 = new Uint8Array(L); w2 !== E; ) {
      for (var k = u[w2], T = 0, S3 = L - 1; (k !== 0 || T < D2) && S3 !== -1; S3--, T++) k += 256 * I2[S3] >>> 0, I2[S3] = k % a >>> 0, k = k / a >>> 0;
      if (k !== 0) throw new Error("Non-zero carry");
      D2 = T, w2++;
    }
    for (var O2 = L - D2; O2 !== L && I2[O2] === 0; ) O2++;
    for (var te2 = c.repeat(m2); O2 < L; ++O2) te2 += r2.charAt(I2[O2]);
    return te2;
  }
  function y2(u) {
    if (typeof u != "string") throw new TypeError("Expected String");
    if (u.length === 0) return new Uint8Array();
    var m2 = 0;
    if (u[m2] !== " ") {
      for (var D2 = 0, w2 = 0; u[m2] === c; ) D2++, m2++;
      for (var E = (u.length - m2) * h3 + 1 >>> 0, L = new Uint8Array(E); u[m2]; ) {
        var I2 = t[u.charCodeAt(m2)];
        if (I2 === 255) return;
        for (var k = 0, T = E - 1; (I2 !== 0 || k < w2) && T !== -1; T--, k++) I2 += a * L[T] >>> 0, L[T] = I2 % 256 >>> 0, I2 = I2 / 256 >>> 0;
        if (I2 !== 0) throw new Error("Non-zero carry");
        w2 = k, m2++;
      }
      if (u[m2] !== " ") {
        for (var S3 = E - w2; S3 !== E && L[S3] === 0; ) S3++;
        for (var O2 = new Uint8Array(D2 + (E - S3)), te2 = D2; S3 !== E; ) O2[te2++] = L[S3++];
        return O2;
      }
    }
  }
  function _(u) {
    var m2 = y2(u);
    if (m2) return m2;
    throw new Error(`Non-${e} character`);
  }
  return { encode: g, decodeUnsafe: y2, decode: _ };
}
var hr = cr;
var lr = hr;
var ri = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array") return r2;
  if (r2 instanceof ArrayBuffer) return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2)) return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ur = (r2) => new TextEncoder().encode(r2);
var dr = (r2) => new TextDecoder().decode(r2);
var pr = class {
  constructor(e, t, i2) {
    this.name = e, this.prefix = t, this.baseEncode = i2;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var gr = class {
  constructor(e, t, i2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ni(this, e);
  }
};
var yr = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ni(this, e);
  }
  decode(e) {
    const t = e[0], i2 = this.decoders[t];
    if (i2) return i2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ni = (r2, e) => new yr({ ...r2.decoders || { [r2.prefix]: r2 }, ...e.decoders || { [e.prefix]: e } });
var br2 = class {
  constructor(e, t, i2, s) {
    this.name = e, this.prefix = t, this.baseEncode = i2, this.baseDecode = s, this.encoder = new pr(e, t, i2), this.decoder = new gr(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Se = ({ name: r2, prefix: e, encode: t, decode: i2 }) => new br2(r2, e, t, i2);
var me2 = ({ prefix: r2, name: e, alphabet: t }) => {
  const { encode: i2, decode: s } = lr(t, e);
  return Se({ prefix: r2, name: e, encode: i2, decode: (n2) => ri(s(n2)) });
};
var mr = (r2, e, t, i2) => {
  const s = {};
  for (let l2 = 0; l2 < e.length; ++l2) s[e[l2]] = l2;
  let n2 = r2.length;
  for (; r2[n2 - 1] === "="; ) --n2;
  const o2 = new Uint8Array(n2 * t / 8 | 0);
  let a = 0, c = 0, h3 = 0;
  for (let l2 = 0; l2 < n2; ++l2) {
    const g = s[r2[l2]];
    if (g === void 0) throw new SyntaxError(`Non-${i2} character`);
    c = c << t | g, a += t, a >= 8 && (a -= 8, o2[h3++] = 255 & c >> a);
  }
  if (a >= t || 255 & c << 8 - a) throw new SyntaxError("Unexpected end of data");
  return o2;
};
var fr = (r2, e, t) => {
  const i2 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let n2 = "", o2 = 0, a = 0;
  for (let c = 0; c < r2.length; ++c) for (a = a << 8 | r2[c], o2 += 8; o2 > t; ) o2 -= t, n2 += e[s & a >> o2];
  if (o2 && (n2 += e[s & a << t - o2]), i2) for (; n2.length * t & 7; ) n2 += "=";
  return n2;
};
var x = ({ name: r2, prefix: e, bitsPerChar: t, alphabet: i2 }) => Se({ prefix: e, name: r2, encode(s) {
  return fr(s, i2, t);
}, decode(s) {
  return mr(s, i2, t, r2);
} });
var Dr2 = Se({ prefix: "\0", name: "identity", encode: (r2) => dr(r2), decode: (r2) => ur(r2) });
var vr = Object.freeze({ __proto__: null, identity: Dr2 });
var _r2 = x({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var wr2 = Object.freeze({ __proto__: null, base2: _r2 });
var Er = x({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Ir = Object.freeze({ __proto__: null, base8: Er });
var Tr2 = me2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Cr2 = Object.freeze({ __proto__: null, base10: Tr2 });
var Pr2 = x({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Sr = x({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Or = Object.freeze({ __proto__: null, base16: Pr2, base16upper: Sr });
var Rr2 = x({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Ar = x({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var xr = x({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Nr2 = x({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var $r2 = x({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var zr = x({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Lr2 = x({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var kr2 = x({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var jr2 = x({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Ur2 = Object.freeze({ __proto__: null, base32: Rr2, base32upper: Ar, base32pad: xr, base32padupper: Nr2, base32hex: $r2, base32hexupper: zr, base32hexpad: Lr2, base32hexpadupper: kr2, base32z: jr2 });
var Fr2 = me2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Mr2 = me2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Kr2 = Object.freeze({ __proto__: null, base36: Fr2, base36upper: Mr2 });
var Br = me2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Vr2 = me2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var qr2 = Object.freeze({ __proto__: null, base58btc: Br, base58flickr: Vr2 });
var Gr = x({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Wr = x({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Hr2 = x({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Yr = x({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Jr = Object.freeze({ __proto__: null, base64: Gr, base64pad: Wr, base64url: Hr2, base64urlpad: Yr });
var oi = Array.from("");
var Xr = oi.reduce((r2, e, t) => (r2[t] = e, r2), []);
var Zr = oi.reduce((r2, e, t) => (r2[e.codePointAt(0)] = t, r2), []);
function Qr(r2) {
  return r2.reduce((e, t) => (e += Xr[t], e), "");
}
function en(r2) {
  const e = [];
  for (const t of r2) {
    const i2 = Zr[t.codePointAt(0)];
    if (i2 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i2);
  }
  return new Uint8Array(e);
}
var tn = Se({ prefix: "", name: "base256emoji", encode: Qr, decode: en });
var sn2 = Object.freeze({ __proto__: null, base256emoji: tn });
var rn2 = ci;
var ai2 = 128;
var nn = 127;
var on = ~nn;
var an2 = Math.pow(2, 31);
function ci(r2, e, t) {
  e = e || [], t = t || 0;
  for (var i2 = t; r2 >= an2; ) e[t++] = r2 & 255 | ai2, r2 /= 128;
  for (; r2 & on; ) e[t++] = r2 & 255 | ai2, r2 >>>= 7;
  return e[t] = r2 | 0, ci.bytes = t - i2 + 1, e;
}
var cn = Ve2;
var hn = 128;
var hi = 127;
function Ve2(r2, i2) {
  var t = 0, i2 = i2 || 0, s = 0, n2 = i2, o2, a = r2.length;
  do {
    if (n2 >= a) throw Ve2.bytes = 0, new RangeError("Could not decode varint");
    o2 = r2[n2++], t += s < 28 ? (o2 & hi) << s : (o2 & hi) * Math.pow(2, s), s += 7;
  } while (o2 >= hn);
  return Ve2.bytes = n2 - i2, t;
}
var ln2 = Math.pow(2, 7);
var un2 = Math.pow(2, 14);
var dn2 = Math.pow(2, 21);
var pn = Math.pow(2, 28);
var gn = Math.pow(2, 35);
var yn = Math.pow(2, 42);
var bn = Math.pow(2, 49);
var mn = Math.pow(2, 56);
var fn2 = Math.pow(2, 63);
var Dn2 = function(r2) {
  return r2 < ln2 ? 1 : r2 < un2 ? 2 : r2 < dn2 ? 3 : r2 < pn ? 4 : r2 < gn ? 5 : r2 < yn ? 6 : r2 < bn ? 7 : r2 < mn ? 8 : r2 < fn2 ? 9 : 10;
};
var vn2 = { encode: rn2, decode: cn, encodingLength: Dn2 };
var li2 = vn2;
var ui2 = (r2, e, t = 0) => (li2.encode(r2, e, t), e);
var di = (r2) => li2.encodingLength(r2);
var qe2 = (r2, e) => {
  const t = e.byteLength, i2 = di(r2), s = i2 + di(t), n2 = new Uint8Array(s + t);
  return ui2(r2, n2, 0), ui2(t, n2, i2), n2.set(e, s), new _n2(r2, t, e, n2);
};
var _n2 = class {
  constructor(e, t, i2, s) {
    this.code = e, this.size = t, this.digest = i2, this.bytes = s;
  }
};
var pi2 = ({ name: r2, code: e, encode: t }) => new wn(r2, e, t);
var wn = class {
  constructor(e, t, i2) {
    this.name = e, this.code = t, this.encode = i2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? qe2(this.code, t) : t.then((i2) => qe2(this.code, i2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var gi = (r2) => async (e) => new Uint8Array(await crypto.subtle.digest(r2, e));
var En2 = pi2({ name: "sha2-256", code: 18, encode: gi("SHA-256") });
var In2 = pi2({ name: "sha2-512", code: 19, encode: gi("SHA-512") });
var Tn2 = Object.freeze({ __proto__: null, sha256: En2, sha512: In2 });
var yi = 0;
var Cn2 = "identity";
var bi = ri;
var Pn2 = (r2) => qe2(yi, bi(r2));
var Sn2 = { code: yi, name: Cn2, encode: bi, digest: Pn2 };
var On2 = Object.freeze({ __proto__: null, identity: Sn2 });
new TextEncoder(), new TextDecoder();
var mi2 = { ...vr, ...wr2, ...Ir, ...Cr2, ...Or, ...Ur2, ...Kr2, ...qr2, ...Jr, ...sn2 };
({ ...Tn2, ...On2 });
function fi(r2) {
  return globalThis.Buffer != null ? new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength) : r2;
}
function Rn2(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? fi(globalThis.Buffer.allocUnsafe(r2)) : new Uint8Array(r2);
}
function Di2(r2, e, t, i2) {
  return { name: r2, prefix: e, encoder: { name: r2, prefix: e, encode: t }, decoder: { decode: i2 } };
}
var vi = Di2("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1)));
var Ge = Di2("ascii", "a", (r2) => {
  let e = "a";
  for (let t = 0; t < r2.length; t++) e += String.fromCharCode(r2[t]);
  return e;
}, (r2) => {
  r2 = r2.substring(1);
  const e = Rn2(r2.length);
  for (let t = 0; t < r2.length; t++) e[t] = r2.charCodeAt(t);
  return e;
});
var An2 = { utf8: vi, "utf-8": vi, hex: mi2.base16, latin1: Ge, ascii: Ge, binary: Ge, ...mi2 };

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/sign-client/dist/index.js
var import_time3 = __toESM(require_cjs());
var Ve3 = "wc";
var ke2 = 2;
var De2 = "client";
var we2 = `${Ve3}@${ke2}:${De2}:`;
var _t2 = "wc";
var ft2 = "auth";
var le2 = `${_t2}@${1.5}:${ft2}:`;
var pe2 = `${le2}:PUB_KEY`;

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/universal-provider/dist/index.js
var import_events5 = __toESM(require_events());
var ht2 = "wc";
var oe2 = "universal_provider";
var A = `${ht2}@2:${oe2}:`;
var pe3 = "https://rpc.walletconnect.org/v1/";
var lt3 = `${pe3}bundler`;

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/SIWXUtil.js
var addEmbeddedWalletSessionPromise = null;
var SIWXUtil = {
  getSIWX() {
    return OptionsController.state.siwx;
  },
  async initializeIfEnabled(caipAddress = ChainController.getActiveCaipAddress()) {
    const siwx = OptionsController.state.siwx;
    if (!(siwx && caipAddress)) {
      return;
    }
    const [namespace, chainId, address] = caipAddress.split(":");
    if (!ChainController.checkIfSupportedNetwork(namespace, `${namespace}:${chainId}`)) {
      return;
    }
    try {
      if (OptionsController.state.remoteFeatures?.emailCapture) {
        const user = ChainController.getAccountData(namespace)?.user;
        await ModalController.open({
          view: "DataCapture",
          data: {
            email: user?.email ?? void 0
          }
        });
        return;
      }
      if (addEmbeddedWalletSessionPromise) {
        await addEmbeddedWalletSessionPromise;
      }
      const sessions = await siwx.getSessions(`${namespace}:${chainId}`, address);
      if (sessions.length) {
        return;
      }
      await ModalController.open({
        view: "SIWXSignMessage"
      });
    } catch (error) {
      console.error("SIWXUtil:initializeIfEnabled", error);
      EventsController.sendEvent({
        type: "track",
        event: "SIWX_AUTH_ERROR",
        properties: this.getSIWXEventProperties(error)
      });
      await ConnectionController._getClient()?.disconnect().catch(console.error);
      RouterController.reset("Connect");
      SnackController.showError("A problem occurred while trying initialize authentication");
    }
  },
  async isAuthenticated(caipAddress = ChainController.getActiveCaipAddress()) {
    const siwx = OptionsController.state.siwx;
    if (!siwx) {
      return true;
    }
    if (!caipAddress) {
      return true;
    }
    const { chainNamespace, chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
    const caipNetworkId = `${chainNamespace}:${chainId}`;
    const sessions = await SIWXUtil.getSessions({
      address,
      caipNetworkId
    });
    return sessions.length > 0;
  },
  async requestSignMessage() {
    const siwx = OptionsController.state.siwx;
    const address = CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress());
    const network = getActiveCaipNetwork();
    const client = ConnectionController._getClient();
    if (!siwx) {
      throw new Error("SIWX is not enabled");
    }
    if (!address) {
      throw new Error("No ActiveCaipAddress found");
    }
    if (!network) {
      throw new Error("No ActiveCaipNetwork or client found");
    }
    if (!client) {
      throw new Error("No ConnectionController client found");
    }
    try {
      const siwxMessage = await siwx.createMessage({
        chainId: network.caipNetworkId,
        accountAddress: address
      });
      const message = siwxMessage.toString();
      const connectorId = ConnectorController.getConnectorId(network.chainNamespace);
      if (connectorId === ConstantsUtil.CONNECTOR_ID.AUTH) {
        RouterController.pushTransactionStack({});
      }
      const signature = await client.signMessage(message);
      await siwx.addSession({
        data: siwxMessage,
        message,
        signature
      });
      ChainController.setLastConnectedSIWECaipNetwork(network);
      ModalController.close();
      EventsController.sendEvent({
        type: "track",
        event: "SIWX_AUTH_SUCCESS",
        properties: this.getSIWXEventProperties()
      });
    } catch (error) {
      if (!ModalController.state.open || RouterController.state.view === "ApproveTransaction") {
        await ModalController.open({
          view: "SIWXSignMessage"
        });
      }
      SnackController.showError("Error signing message");
      EventsController.sendEvent({
        type: "track",
        event: "SIWX_AUTH_ERROR",
        properties: this.getSIWXEventProperties(error)
      });
      console.error("SWIXUtil:requestSignMessage", error);
    }
  },
  async cancelSignMessage() {
    try {
      const siwx = this.getSIWX();
      const isRequired = siwx?.getRequired?.();
      if (isRequired) {
        const lastNetwork = ChainController.getLastConnectedSIWECaipNetwork();
        if (lastNetwork) {
          const sessions = await siwx?.getSessions(lastNetwork?.caipNetworkId, CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress()) || "");
          if (sessions && sessions.length > 0) {
            await ChainController.switchActiveNetwork(lastNetwork);
          } else {
            await ConnectionController.disconnect();
          }
        } else {
          await ConnectionController.disconnect();
        }
      } else {
        ModalController.close();
      }
      ModalController.close();
      EventsController.sendEvent({
        event: "CLICK_CANCEL_SIWX",
        type: "track",
        properties: this.getSIWXEventProperties()
      });
    } catch (error) {
      console.error("SIWXUtil:cancelSignMessage", error);
    }
  },
  async getAllSessions() {
    const siwx = this.getSIWX();
    const allRequestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const sessions = [];
    await Promise.all(allRequestedCaipNetworks.map(async (caipNetwork) => {
      const session = await siwx?.getSessions(caipNetwork.caipNetworkId, CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress()) || "");
      if (session) {
        sessions.push(...session);
      }
    }));
    return sessions;
  },
  async getSessions(args) {
    const siwx = OptionsController.state.siwx;
    let address = args?.address;
    if (!address) {
      const activeCaipAddress = ChainController.getActiveCaipAddress();
      address = CoreHelperUtil.getPlainAddress(activeCaipAddress);
    }
    let network = args?.caipNetworkId;
    if (!network) {
      const activeCaipNetwork = ChainController.getActiveCaipNetwork();
      network = activeCaipNetwork?.caipNetworkId;
    }
    if (!(siwx && address && network)) {
      return [];
    }
    return siwx.getSessions(network, address);
  },
  async isSIWXCloseDisabled() {
    const siwx = this.getSIWX();
    if (siwx) {
      const isApproveSignScreen = RouterController.state.view === "ApproveTransaction";
      const isSiwxSignMessage = RouterController.state.view === "SIWXSignMessage";
      if (isApproveSignScreen || isSiwxSignMessage) {
        return siwx.getRequired?.() && (await this.getSessions()).length === 0;
      }
    }
    return false;
  },
  async authConnectorAuthenticate({ authConnector, chainId, socialUri, preferredAccountType, chainNamespace }) {
    const siwx = SIWXUtil.getSIWX();
    const network = getActiveCaipNetwork();
    if (!siwx || !chainNamespace.includes(ConstantsUtil.CHAIN.EVM) || // Request to input email and sign message when email capture is enabled
    OptionsController.state.remoteFeatures?.emailCapture) {
      const result2 = await authConnector.connect({
        chainId,
        socialUri,
        preferredAccountType
      });
      return {
        address: result2.address,
        chainId: result2.chainId,
        accounts: result2.accounts
      };
    }
    const caipNetwork = `${chainNamespace}:${chainId}`;
    const siwxMessage = await siwx.createMessage({
      chainId: caipNetwork,
      accountAddress: "<<AccountAddress>>"
    });
    const siwxMessageData = {
      accountAddress: siwxMessage.accountAddress,
      chainId: siwxMessage.chainId,
      domain: siwxMessage.domain,
      uri: siwxMessage.uri,
      version: siwxMessage.version,
      nonce: siwxMessage.nonce,
      notBefore: siwxMessage.notBefore,
      statement: siwxMessage.statement,
      resources: siwxMessage.resources,
      requestId: siwxMessage.requestId,
      issuedAt: siwxMessage.issuedAt,
      expirationTime: siwxMessage.expirationTime,
      serializedMessage: siwxMessage.toString()
    };
    const result = await authConnector.connect({
      chainId,
      socialUri,
      siwxMessage: siwxMessageData,
      preferredAccountType
    });
    siwxMessageData.accountAddress = result.address;
    siwxMessageData.serializedMessage = result.message || "";
    if (result.signature && result.message) {
      const promise = SIWXUtil.addEmbeddedWalletSession(siwxMessageData, result.message, result.signature);
      await promise;
    }
    ChainController.setLastConnectedSIWECaipNetwork(network);
    return {
      address: result.address,
      chainId: result.chainId,
      accounts: result.accounts
    };
  },
  async addEmbeddedWalletSession(siwxMessageData, message, signature) {
    if (addEmbeddedWalletSessionPromise) {
      return addEmbeddedWalletSessionPromise;
    }
    const siwx = SIWXUtil.getSIWX();
    if (!siwx) {
      return Promise.resolve();
    }
    addEmbeddedWalletSessionPromise = siwx.addSession({
      data: siwxMessageData,
      message,
      signature
    }).finally(() => {
      addEmbeddedWalletSessionPromise = null;
    });
    return addEmbeddedWalletSessionPromise;
  },
  async universalProviderAuthenticate({ universalProvider, chains, methods }) {
    const siwx = SIWXUtil.getSIWX();
    const network = getActiveCaipNetwork();
    const namespaces = new Set(chains.map((chain) => chain.split(":")[0]));
    if (!siwx || namespaces.size !== 1 || !namespaces.has("eip155")) {
      return false;
    }
    const siwxMessage = await siwx.createMessage({
      chainId: getActiveCaipNetwork()?.caipNetworkId || "",
      accountAddress: ""
    });
    const result = await universalProvider.authenticate({
      nonce: siwxMessage.nonce,
      domain: siwxMessage.domain,
      uri: siwxMessage.uri,
      exp: siwxMessage.expirationTime,
      iat: siwxMessage.issuedAt,
      nbf: siwxMessage.notBefore,
      requestId: siwxMessage.requestId,
      version: siwxMessage.version,
      resources: siwxMessage.resources,
      statement: siwxMessage.statement,
      chainId: siwxMessage.chainId,
      methods,
      // The first chainId is what is used for universal provider to build the message
      chains: [siwxMessage.chainId, ...chains.filter((chain) => chain !== siwxMessage.chainId)]
    });
    SnackController.showLoading("Authenticating...", { autoClose: false });
    const walletInfo = {
      ...result.session.peer.metadata,
      name: result.session.peer.metadata.name,
      icon: result.session.peer.metadata.icons?.[0],
      type: "WALLET_CONNECT"
    };
    ChainController.setAccountProp("connectedWalletInfo", walletInfo, Array.from(namespaces)[0]);
    if (result?.auths?.length) {
      const sessions = result.auths.map((cacao) => {
        const message = universalProvider.client.formatAuthMessage({
          request: cacao.p,
          iss: cacao.p.iss
        });
        return {
          data: {
            ...cacao.p,
            accountAddress: cacao.p.iss.split(":").slice(-1).join(""),
            chainId: cacao.p.iss.split(":").slice(2, 4).join(":"),
            uri: cacao.p.aud,
            version: cacao.p.version || siwxMessage.version,
            expirationTime: cacao.p.exp,
            issuedAt: cacao.p.iat,
            notBefore: cacao.p.nbf
          },
          message,
          signature: cacao.s.s,
          cacao
        };
      });
      try {
        await siwx.setSessions(sessions);
        if (network) {
          ChainController.setLastConnectedSIWECaipNetwork(network);
        }
        EventsController.sendEvent({
          type: "track",
          event: "SIWX_AUTH_SUCCESS",
          properties: SIWXUtil.getSIWXEventProperties()
        });
      } catch (error) {
        console.error("SIWX:universalProviderAuth - failed to set sessions", error);
        EventsController.sendEvent({
          type: "track",
          event: "SIWX_AUTH_ERROR",
          properties: SIWXUtil.getSIWXEventProperties(error)
        });
        await universalProvider.disconnect().catch(console.error);
        throw error;
      } finally {
        SnackController.hide();
      }
    }
    return true;
  },
  getSIWXEventProperties(error) {
    const namespace = ChainController.state.activeChain;
    if (!namespace) {
      throw new Error("SIWXUtil:getSIWXEventProperties - namespace is required");
    }
    return {
      network: ChainController.state.activeCaipNetwork?.caipNetworkId || "",
      isSmartAccount: getPreferredAccountType(namespace) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
      message: error ? CoreHelperUtil.parseError(error) : void 0
    };
  },
  async clearSessions() {
    const siwx = this.getSIWX();
    if (siwx) {
      await siwx.setSessions([]);
    }
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/SwapCalculationUtil.js
var SwapCalculationUtil = {
  getGasPriceInEther(gas, gasPrice) {
    const totalGasCostInWei = gasPrice * gas;
    const totalGasCostInEther = Number(totalGasCostInWei) / 1e18;
    return totalGasCostInEther;
  },
  getGasPriceInUSD(networkPrice, gas, gasPrice) {
    const totalGasCostInEther = SwapCalculationUtil.getGasPriceInEther(gas, gasPrice);
    const networkPriceInUSD = NumberUtil.bigNumber(networkPrice);
    const gasCostInUSD = networkPriceInUSD.times(totalGasCostInEther);
    return gasCostInUSD.toNumber();
  },
  getPriceImpact({ sourceTokenAmount, sourceTokenPriceInUSD, toTokenPriceInUSD, toTokenAmount }) {
    const inputValue = NumberUtil.bigNumber(sourceTokenAmount).times(sourceTokenPriceInUSD);
    const outputValue = NumberUtil.bigNumber(toTokenAmount).times(toTokenPriceInUSD);
    const priceImpact = inputValue.minus(outputValue).div(inputValue).times(100);
    return priceImpact.toNumber();
  },
  getMaxSlippage(slippage, toTokenAmount) {
    const slippageToleranceDecimal = NumberUtil.bigNumber(slippage).div(100);
    const maxSlippageAmount = NumberUtil.multiply(toTokenAmount, slippageToleranceDecimal);
    return maxSlippageAmount.toNumber();
  },
  getProviderFee(sourceTokenAmount, feePercentage = 85e-4) {
    const providerFee = NumberUtil.bigNumber(sourceTokenAmount).times(feePercentage);
    return providerFee.toString();
  },
  isInsufficientNetworkTokenForGas(networkBalanceInUSD, gasPriceInUSD) {
    const gasPrice = gasPriceInUSD || "0";
    if (NumberUtil.bigNumber(networkBalanceInUSD).eq(0)) {
      return true;
    }
    return NumberUtil.bigNumber(NumberUtil.bigNumber(gasPrice)).gt(networkBalanceInUSD);
  },
  isInsufficientSourceTokenForSwap(sourceTokenAmount, sourceTokenAddress, balance) {
    const sourceTokenBalance = balance?.find((token) => token.address === sourceTokenAddress)?.quantity?.numeric;
    const isInSufficientBalance = NumberUtil.bigNumber(sourceTokenBalance || "0").lt(sourceTokenAmount);
    return isInSufficientBalance;
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AlertController.js
var state = proxy({
  message: "",
  variant: "info",
  open: false
});
var controller = {
  state,
  subscribeKey(key, callback) {
    return subscribeKey(state, key, callback);
  },
  open(message, variant) {
    const { debug } = OptionsController.state;
    const { code, displayMessage, debugMessage } = message;
    if (displayMessage && debug) {
      state.message = displayMessage;
      state.variant = variant;
      state.open = true;
    }
    if (debugMessage) {
      console.error(typeof debugMessage === "function" ? debugMessage() : debugMessage, code ? { code } : void 0);
    }
  },
  warn(title, description, code) {
    state.open = true;
    state.message = title;
    state.variant = "warning";
    if (description) {
      console.warn(description, code);
    }
  },
  close() {
    state.open = false;
    state.message = "";
    state.variant = "info";
  }
};
var AlertController = withErrorBoundary(controller);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SwapController.js
var INITIAL_GAS_LIMIT = 15e4;
var TO_AMOUNT_DECIMALS = 6;
var initialState = {
  // Loading states
  initializing: false,
  initialized: false,
  loadingPrices: false,
  loadingQuote: false,
  loadingApprovalTransaction: false,
  loadingBuildTransaction: false,
  loadingTransaction: false,
  // Control states
  switchingTokens: false,
  // Error states
  fetchError: false,
  // Approval & Swap transaction states
  approvalTransaction: void 0,
  swapTransaction: void 0,
  transactionError: void 0,
  // Input values
  sourceToken: void 0,
  sourceTokenAmount: "",
  sourceTokenPriceInUSD: 0,
  toToken: void 0,
  toTokenAmount: "",
  toTokenPriceInUSD: 0,
  networkPrice: "0",
  networkBalanceInUSD: "0",
  networkTokenSymbol: "",
  inputError: void 0,
  // Request values
  slippage: ConstantsUtil2.CONVERT_SLIPPAGE_TOLERANCE,
  // Tokens
  tokens: void 0,
  popularTokens: void 0,
  suggestedTokens: void 0,
  foundTokens: void 0,
  myTokensWithBalance: void 0,
  tokensPriceMap: {},
  // Calculations
  gasFee: "0",
  gasPriceInUSD: 0,
  priceImpact: void 0,
  maxSlippage: void 0,
  providerFee: void 0
};
var state2 = proxy({ ...initialState });
var controller2 = {
  state: state2,
  subscribe(callback) {
    return subscribe(state2, () => callback(state2));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state2, key, callback);
  },
  getParams() {
    const namespace = ChainController.state.activeChain;
    const caipAddress = ChainController.getAccountData(namespace)?.caipAddress ?? ChainController.state.activeCaipAddress;
    const address = CoreHelperUtil.getPlainAddress(caipAddress);
    const networkAddress = getActiveNetworkTokenAddress();
    const connectorId = ConnectorController.getConnectorId(ChainController.state.activeChain);
    if (!address) {
      throw new Error("No address found to swap the tokens from.");
    }
    const invalidToToken = !state2.toToken?.address || !state2.toToken?.decimals;
    const invalidSourceToken = !state2.sourceToken?.address || !state2.sourceToken?.decimals || !NumberUtil.bigNumber(state2.sourceTokenAmount).gt(0);
    const invalidSourceTokenAmount = !state2.sourceTokenAmount;
    return {
      networkAddress,
      fromAddress: address,
      fromCaipAddress: caipAddress,
      sourceTokenAddress: state2.sourceToken?.address,
      toTokenAddress: state2.toToken?.address,
      toTokenAmount: state2.toTokenAmount,
      toTokenDecimals: state2.toToken?.decimals,
      sourceTokenAmount: state2.sourceTokenAmount,
      sourceTokenDecimals: state2.sourceToken?.decimals,
      invalidToToken,
      invalidSourceToken,
      invalidSourceTokenAmount,
      availableToSwap: caipAddress && !invalidToToken && !invalidSourceToken && !invalidSourceTokenAmount,
      isAuthConnector: connectorId === ConstantsUtil.CONNECTOR_ID.AUTH
    };
  },
  async setSourceToken(sourceToken) {
    if (!sourceToken) {
      state2.sourceToken = sourceToken;
      state2.sourceTokenAmount = "";
      state2.sourceTokenPriceInUSD = 0;
      return;
    }
    state2.sourceToken = sourceToken;
    await SwapController.setTokenPrice(sourceToken.address, "sourceToken");
  },
  setSourceTokenAmount(amount) {
    state2.sourceTokenAmount = amount;
  },
  async setToToken(toToken) {
    if (!toToken) {
      state2.toToken = toToken;
      state2.toTokenAmount = "";
      state2.toTokenPriceInUSD = 0;
      return;
    }
    state2.toToken = toToken;
    await SwapController.setTokenPrice(toToken.address, "toToken");
  },
  setToTokenAmount(amount) {
    state2.toTokenAmount = amount ? NumberUtil.toFixed(amount, TO_AMOUNT_DECIMALS) : "";
  },
  async setTokenPrice(address, target) {
    let price = state2.tokensPriceMap[address] || 0;
    if (!price) {
      state2.loadingPrices = true;
      price = await SwapController.getAddressPrice(address);
    }
    if (target === "sourceToken") {
      state2.sourceTokenPriceInUSD = price;
    } else if (target === "toToken") {
      state2.toTokenPriceInUSD = price;
    }
    if (state2.loadingPrices) {
      state2.loadingPrices = false;
    }
    if (SwapController.getParams().availableToSwap && !state2.switchingTokens) {
      SwapController.swapTokens();
    }
  },
  async switchTokens() {
    if (state2.initializing || !state2.initialized || state2.switchingTokens) {
      return;
    }
    state2.switchingTokens = true;
    try {
      const newSourceToken = state2.toToken ? { ...state2.toToken } : void 0;
      const newToToken = state2.sourceToken ? { ...state2.sourceToken } : void 0;
      const newSourceTokenAmount = newSourceToken && state2.toTokenAmount === "" ? "1" : state2.toTokenAmount;
      SwapController.setSourceTokenAmount(newSourceTokenAmount);
      SwapController.setToTokenAmount("");
      await SwapController.setSourceToken(newSourceToken);
      await SwapController.setToToken(newToToken);
      state2.switchingTokens = false;
      SwapController.swapTokens();
    } catch (error) {
      state2.switchingTokens = false;
      throw error;
    }
  },
  resetState() {
    state2.myTokensWithBalance = initialState.myTokensWithBalance;
    state2.tokensPriceMap = initialState.tokensPriceMap;
    state2.initialized = initialState.initialized;
    state2.initializing = initialState.initializing;
    state2.switchingTokens = initialState.switchingTokens;
    state2.sourceToken = initialState.sourceToken;
    state2.sourceTokenAmount = initialState.sourceTokenAmount;
    state2.sourceTokenPriceInUSD = initialState.sourceTokenPriceInUSD;
    state2.toToken = initialState.toToken;
    state2.toTokenAmount = initialState.toTokenAmount;
    state2.toTokenPriceInUSD = initialState.toTokenPriceInUSD;
    state2.networkPrice = initialState.networkPrice;
    state2.networkTokenSymbol = initialState.networkTokenSymbol;
    state2.networkBalanceInUSD = initialState.networkBalanceInUSD;
    state2.inputError = initialState.inputError;
  },
  resetValues() {
    const { networkAddress } = SwapController.getParams();
    const networkToken = state2.tokens?.find((token) => token.address === networkAddress);
    SwapController.setSourceToken(networkToken);
    SwapController.setToToken(void 0);
  },
  getApprovalLoadingState() {
    return state2.loadingApprovalTransaction;
  },
  clearError() {
    state2.transactionError = void 0;
  },
  async initializeState() {
    if (state2.initializing) {
      return;
    }
    state2.initializing = true;
    if (!state2.initialized) {
      try {
        await SwapController.fetchTokens();
        state2.initialized = true;
      } catch (error) {
        state2.initialized = false;
        SnackController.showError("Failed to initialize swap");
        RouterController.goBack();
      }
    }
    state2.initializing = false;
  },
  async fetchTokens() {
    const { networkAddress } = SwapController.getParams();
    await SwapController.getNetworkTokenPrice();
    await SwapController.getMyTokensWithBalance();
    const networkToken = state2.myTokensWithBalance?.find((token) => token.address === networkAddress);
    if (networkToken) {
      state2.networkTokenSymbol = networkToken.symbol;
      SwapController.setSourceToken(networkToken);
      SwapController.setSourceTokenAmount("0");
    }
  },
  async getTokenList() {
    const activeCaipNetworkId = ChainController.state.activeCaipNetwork?.caipNetworkId;
    if (state2.caipNetworkId === activeCaipNetworkId && state2.tokens) {
      return;
    }
    try {
      state2.tokensLoading = true;
      const tokens2 = await SwapApiUtil.getTokenList(activeCaipNetworkId);
      state2.tokens = tokens2;
      state2.caipNetworkId = activeCaipNetworkId;
      state2.popularTokens = tokens2.sort((aTokenInfo, bTokenInfo) => {
        if (aTokenInfo.symbol < bTokenInfo.symbol) {
          return -1;
        }
        if (aTokenInfo.symbol > bTokenInfo.symbol) {
          return 1;
        }
        return 0;
      });
      const suggestedTokensByChain = activeCaipNetworkId && ConstantsUtil2.SUGGESTED_TOKENS_BY_CHAIN?.[activeCaipNetworkId] || [];
      const suggestedTokenObjects = suggestedTokensByChain.map((symbol) => tokens2.find((t) => t.symbol === symbol)).filter((t) => Boolean(t));
      const allSuggestedTokens = ConstantsUtil2.SWAP_SUGGESTED_TOKENS || [];
      const allSuggestedTokenObjects = allSuggestedTokens.map((symbol) => tokens2.find((t) => t.symbol === symbol)).filter((t) => Boolean(t)).filter((t) => !suggestedTokenObjects.some((ct3) => ct3.address === t.address));
      state2.suggestedTokens = [...suggestedTokenObjects, ...allSuggestedTokenObjects];
    } catch (error) {
      state2.tokens = [];
      state2.popularTokens = [];
      state2.suggestedTokens = [];
    } finally {
      state2.tokensLoading = false;
    }
  },
  async getAddressPrice(address) {
    const existPrice = state2.tokensPriceMap[address];
    if (existPrice) {
      return existPrice;
    }
    const response = await BlockchainApiController.fetchTokenPrice({
      addresses: [address]
    });
    const fungibles = response?.fungibles || [];
    const allTokens = [...state2.tokens || [], ...state2.myTokensWithBalance || []];
    const symbol = allTokens?.find((token) => token.address === address)?.symbol;
    const price = fungibles.find((p) => p.symbol.toLowerCase() === symbol?.toLowerCase())?.price || 0;
    const priceAsFloat = parseFloat(price.toString());
    state2.tokensPriceMap[address] = priceAsFloat;
    return priceAsFloat;
  },
  async getNetworkTokenPrice() {
    const { networkAddress } = SwapController.getParams();
    const response = await BlockchainApiController.fetchTokenPrice({
      addresses: [networkAddress]
    }).catch(() => {
      SnackController.showError("Failed to fetch network token price");
      return { fungibles: [] };
    });
    const token = response.fungibles?.[0];
    const price = token?.price.toString() || "0";
    state2.tokensPriceMap[networkAddress] = parseFloat(price);
    state2.networkTokenSymbol = token?.symbol || "";
    state2.networkPrice = price;
  },
  async getMyTokensWithBalance(forceUpdate) {
    const balances = await BalanceUtil.getMyTokensWithBalance(forceUpdate);
    const swapBalances = SwapApiUtil.mapBalancesToSwapTokens(balances);
    if (!swapBalances) {
      return;
    }
    await SwapController.getInitialGasPrice();
    SwapController.setBalances(swapBalances);
  },
  setBalances(balances) {
    const { networkAddress } = SwapController.getParams();
    const caipNetwork = ChainController.state.activeCaipNetwork;
    if (!caipNetwork) {
      return;
    }
    const networkToken = balances.find((token) => token.address === networkAddress);
    balances.forEach((token) => {
      state2.tokensPriceMap[token.address] = token.price || 0;
    });
    state2.myTokensWithBalance = balances.filter((token) => token.address.startsWith(caipNetwork.caipNetworkId));
    state2.networkBalanceInUSD = networkToken ? NumberUtil.multiply(networkToken.quantity.numeric, networkToken.price).toString() : "0";
  },
  async getInitialGasPrice() {
    const res = await SwapApiUtil.fetchGasPrice();
    if (!res) {
      return { gasPrice: null, gasPriceInUSD: null };
    }
    switch (ChainController.state?.activeCaipNetwork?.chainNamespace) {
      case ConstantsUtil.CHAIN.SOLANA:
        state2.gasFee = res.standard ?? "0";
        state2.gasPriceInUSD = NumberUtil.multiply(res.standard, state2.networkPrice).div(1e9).toNumber();
        return {
          gasPrice: BigInt(state2.gasFee),
          gasPriceInUSD: Number(state2.gasPriceInUSD)
        };
      case ConstantsUtil.CHAIN.EVM:
      default:
        const value = res.standard ?? "0";
        const gasFee = BigInt(value);
        const gasLimit = BigInt(INITIAL_GAS_LIMIT);
        const gasPrice = SwapCalculationUtil.getGasPriceInUSD(state2.networkPrice, gasLimit, gasFee);
        state2.gasFee = value;
        state2.gasPriceInUSD = gasPrice;
        return { gasPrice: gasFee, gasPriceInUSD: gasPrice };
    }
  },
  // -- Swap -------------------------------------- //
  async swapTokens() {
    const address = ChainController.getAccountData()?.address;
    const sourceToken = state2.sourceToken;
    const toToken = state2.toToken;
    const haveSourceTokenAmount = NumberUtil.bigNumber(state2.sourceTokenAmount).gt(0);
    if (!haveSourceTokenAmount) {
      SwapController.setToTokenAmount("");
    }
    if (!toToken || !sourceToken || state2.loadingPrices || !haveSourceTokenAmount || !address) {
      return;
    }
    state2.loadingQuote = true;
    const amountDecimal = NumberUtil.bigNumber(state2.sourceTokenAmount).times(10 ** sourceToken.decimals).round(0);
    try {
      const quoteResponse = await BlockchainApiController.fetchSwapQuote({
        userAddress: address,
        from: sourceToken.address,
        to: toToken.address,
        gasPrice: state2.gasFee,
        amount: amountDecimal.toString()
      });
      state2.loadingQuote = false;
      const quoteToAmount = quoteResponse?.quotes?.[0]?.toAmount;
      if (!quoteToAmount) {
        AlertController.open({
          displayMessage: "Incorrect amount",
          debugMessage: "Please enter a valid amount"
        }, "error");
        return;
      }
      const toTokenAmount = NumberUtil.bigNumber(quoteToAmount).div(10 ** toToken.decimals).toString();
      SwapController.setToTokenAmount(toTokenAmount);
      const isInsufficientToken = SwapController.hasInsufficientToken(state2.sourceTokenAmount, sourceToken.address);
      if (isInsufficientToken) {
        state2.inputError = "Insufficient balance";
      } else {
        state2.inputError = void 0;
        SwapController.setTransactionDetails();
      }
    } catch (error) {
      const response = await SwapApiUtil.handleSwapError(error);
      state2.loadingQuote = false;
      state2.inputError = response || "Insufficient balance";
    }
  },
  // -- Create Transactions -------------------------------------- //
  async getTransaction() {
    const { fromCaipAddress, availableToSwap } = SwapController.getParams();
    const sourceToken = state2.sourceToken;
    const toToken = state2.toToken;
    if (!fromCaipAddress || !availableToSwap || !sourceToken || !toToken || state2.loadingQuote) {
      return void 0;
    }
    try {
      state2.loadingBuildTransaction = true;
      const hasAllowance = await SwapApiUtil.fetchSwapAllowance({
        userAddress: fromCaipAddress,
        tokenAddress: sourceToken.address,
        sourceTokenAmount: state2.sourceTokenAmount,
        sourceTokenDecimals: sourceToken.decimals
      });
      let transaction = void 0;
      if (hasAllowance) {
        transaction = await SwapController.createSwapTransaction();
      } else {
        transaction = await SwapController.createAllowanceTransaction();
      }
      state2.loadingBuildTransaction = false;
      state2.fetchError = false;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to check allowance");
      state2.loadingBuildTransaction = false;
      state2.approvalTransaction = void 0;
      state2.swapTransaction = void 0;
      state2.fetchError = true;
      return void 0;
    }
  },
  async createAllowanceTransaction() {
    const { fromCaipAddress, sourceTokenAddress, toTokenAddress } = SwapController.getParams();
    if (!fromCaipAddress || !toTokenAddress) {
      return void 0;
    }
    if (!sourceTokenAddress) {
      throw new Error("createAllowanceTransaction - No source token address found.");
    }
    try {
      const response = await BlockchainApiController.generateApproveCalldata({
        from: sourceTokenAddress,
        to: toTokenAddress,
        userAddress: fromCaipAddress
      });
      const address = CoreHelperUtil.getPlainAddress(response.tx.from);
      if (!address) {
        throw new Error("SwapController:createAllowanceTransaction - address is required");
      }
      const transaction = {
        data: response.tx.data,
        to: address,
        gasPrice: BigInt(response.tx.eip155.gasPrice),
        value: BigInt(response.tx.value),
        toAmount: state2.toTokenAmount
      };
      state2.swapTransaction = void 0;
      state2.approvalTransaction = {
        data: transaction.data,
        to: transaction.to,
        gasPrice: transaction.gasPrice,
        value: transaction.value,
        toAmount: transaction.toAmount
      };
      return {
        data: transaction.data,
        to: transaction.to,
        gasPrice: transaction.gasPrice,
        value: transaction.value,
        toAmount: transaction.toAmount
      };
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to create approval transaction");
      state2.approvalTransaction = void 0;
      state2.swapTransaction = void 0;
      state2.fetchError = true;
      return void 0;
    }
  },
  async createSwapTransaction() {
    const { networkAddress, fromCaipAddress, sourceTokenAmount } = SwapController.getParams();
    const sourceToken = state2.sourceToken;
    const toToken = state2.toToken;
    if (!fromCaipAddress || !sourceTokenAmount || !sourceToken || !toToken) {
      return void 0;
    }
    const amount = ConnectionController.parseUnits(sourceTokenAmount, sourceToken.decimals)?.toString();
    try {
      const response = await BlockchainApiController.generateSwapCalldata({
        userAddress: fromCaipAddress,
        from: sourceToken.address,
        to: toToken.address,
        amount,
        disableEstimate: true
      });
      const isSourceTokenIsNetworkToken = sourceToken.address === networkAddress;
      const gas = BigInt(response.tx.eip155.gas);
      const gasPrice = BigInt(response.tx.eip155.gasPrice);
      const address = CoreHelperUtil.getPlainAddress(response.tx.to);
      if (!address) {
        throw new Error("SwapController:createSwapTransaction - address is required");
      }
      const transaction = {
        data: response.tx.data,
        to: address,
        gas,
        gasPrice,
        value: isSourceTokenIsNetworkToken ? BigInt(amount ?? "0") : BigInt("0"),
        toAmount: state2.toTokenAmount
      };
      state2.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state2.networkPrice, gas, gasPrice);
      state2.approvalTransaction = void 0;
      state2.swapTransaction = transaction;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to create transaction");
      state2.approvalTransaction = void 0;
      state2.swapTransaction = void 0;
      state2.fetchError = true;
      return void 0;
    }
  },
  onEmbeddedWalletApprovalSuccess() {
    SnackController.showLoading("Approve limit increase in your wallet");
    RouterController.replace("SwapPreview");
  },
  // -- Send Transactions --------------------------------- //
  async sendTransactionForApproval(data) {
    const { fromAddress, isAuthConnector } = SwapController.getParams();
    state2.loadingApprovalTransaction = true;
    const approveLimitMessage = `Approve limit increase in your wallet`;
    if (isAuthConnector) {
      RouterController.pushTransactionStack({
        onSuccess: SwapController.onEmbeddedWalletApprovalSuccess
      });
    } else {
      SnackController.showLoading(approveLimitMessage);
    }
    try {
      await ConnectionController.sendTransaction({
        address: fromAddress,
        to: data.to,
        data: data.data,
        value: data.value,
        chainNamespace: ConstantsUtil.CHAIN.EVM
      });
      await SwapController.swapTokens();
      await SwapController.getTransaction();
      state2.approvalTransaction = void 0;
      state2.loadingApprovalTransaction = false;
    } catch (err) {
      const error = err;
      state2.transactionError = error?.displayMessage;
      state2.loadingApprovalTransaction = false;
      SnackController.showError(error?.displayMessage || "Transaction error");
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_APPROVAL_ERROR",
        properties: {
          message: error?.displayMessage || error?.message || "Unknown",
          network: ChainController.state.activeCaipNetwork?.caipNetworkId || "",
          swapFromToken: SwapController.state.sourceToken?.symbol || "",
          swapToToken: SwapController.state.toToken?.symbol || "",
          swapFromAmount: SwapController.state.sourceTokenAmount || "",
          swapToAmount: SwapController.state.toTokenAmount || "",
          isSmartAccount: getPreferredAccountType(ConstantsUtil.CHAIN.EVM) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
    }
  },
  async sendTransactionForSwap(data) {
    if (!data) {
      return void 0;
    }
    const { fromAddress, toTokenAmount, isAuthConnector } = SwapController.getParams();
    state2.loadingTransaction = true;
    const snackbarPendingMessage = `Swapping ${state2.sourceToken?.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${state2.toToken?.symbol}`;
    const snackbarSuccessMessage = `Swapped ${state2.sourceToken?.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${state2.toToken?.symbol}`;
    if (isAuthConnector) {
      RouterController.pushTransactionStack({
        onSuccess() {
          RouterController.replace("Account");
          SnackController.showLoading(snackbarPendingMessage);
          controller2.resetState();
        }
      });
    } else {
      SnackController.showLoading("Confirm transaction in your wallet");
    }
    try {
      const forceUpdateAddresses = [state2.sourceToken?.address, state2.toToken?.address].join(",");
      const transactionHash = await ConnectionController.sendTransaction({
        address: fromAddress,
        to: data.to,
        data: data.data,
        value: data.value,
        chainNamespace: ConstantsUtil.CHAIN.EVM
      });
      state2.loadingTransaction = false;
      SnackController.showSuccess(snackbarSuccessMessage);
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_SUCCESS",
        properties: {
          network: ChainController.state.activeCaipNetwork?.caipNetworkId || "",
          swapFromToken: SwapController.state.sourceToken?.symbol || "",
          swapToToken: SwapController.state.toToken?.symbol || "",
          swapFromAmount: SwapController.state.sourceTokenAmount || "",
          swapToAmount: SwapController.state.toTokenAmount || "",
          isSmartAccount: getPreferredAccountType(ConstantsUtil.CHAIN.EVM) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      controller2.resetState();
      if (!isAuthConnector) {
        RouterController.replace("Account");
      }
      controller2.getMyTokensWithBalance(forceUpdateAddresses);
      return transactionHash;
    } catch (err) {
      const error = err;
      state2.transactionError = error?.displayMessage;
      state2.loadingTransaction = false;
      SnackController.showError(error?.displayMessage || "Transaction error");
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_ERROR",
        properties: {
          message: error?.displayMessage || error?.message || "Unknown",
          network: ChainController.state.activeCaipNetwork?.caipNetworkId || "",
          swapFromToken: SwapController.state.sourceToken?.symbol || "",
          swapToToken: SwapController.state.toToken?.symbol || "",
          swapFromAmount: SwapController.state.sourceTokenAmount || "",
          swapToAmount: SwapController.state.toTokenAmount || "",
          isSmartAccount: getPreferredAccountType(ConstantsUtil.CHAIN.EVM) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      return void 0;
    }
  },
  // -- Checks -------------------------------------------- //
  hasInsufficientToken(sourceTokenAmount, sourceTokenAddress) {
    const isInsufficientSourceTokenForSwap = SwapCalculationUtil.isInsufficientSourceTokenForSwap(sourceTokenAmount, sourceTokenAddress, state2.myTokensWithBalance);
    return isInsufficientSourceTokenForSwap;
  },
  // -- Calculations -------------------------------------- //
  setTransactionDetails() {
    const { toTokenAddress, toTokenDecimals } = SwapController.getParams();
    if (!toTokenAddress || !toTokenDecimals) {
      return;
    }
    state2.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state2.networkPrice, BigInt(state2.gasFee), BigInt(INITIAL_GAS_LIMIT));
    state2.priceImpact = SwapCalculationUtil.getPriceImpact({
      sourceTokenAmount: state2.sourceTokenAmount,
      sourceTokenPriceInUSD: state2.sourceTokenPriceInUSD,
      toTokenPriceInUSD: state2.toTokenPriceInUSD,
      toTokenAmount: state2.toTokenAmount
    });
    state2.maxSlippage = SwapCalculationUtil.getMaxSlippage(state2.slippage, state2.toTokenAmount);
    state2.providerFee = SwapCalculationUtil.getProviderFee(state2.sourceTokenAmount);
  }
};
var SwapController = withErrorBoundary(controller2);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ModalUtil.js
var ModalUtil = {
  isUnsupportedChainView() {
    return RouterController.state.view === "UnsupportedChain" || RouterController.state.view === "SwitchNetwork" && RouterController.state.history.includes("UnsupportedChain");
  },
  async safeClose() {
    if (this.isUnsupportedChainView()) {
      ModalController.shake();
      return;
    }
    const isSIWXCloseDisabled = await SIWXUtil.isSIWXCloseDisabled();
    if (isSIWXCloseDisabled) {
      ModalController.shake();
      return;
    }
    if (RouterController.state.view === "DataCapture" || RouterController.state.view === "DataCaptureOtpConfirm") {
      ConnectionController.disconnect();
    }
    ModalController.close();
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OnRampController.js
var USDC_CURRENCY_DEFAULT = {
  id: "2b92315d-eab7-5bef-84fa-089a131333f5",
  name: "USD Coin",
  symbol: "USDC",
  networks: [
    {
      name: "ethereum-mainnet",
      display_name: "Ethereum",
      chain_id: "1",
      contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    },
    {
      name: "polygon-mainnet",
      display_name: "Polygon",
      chain_id: "137",
      contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
    }
  ]
};
var USD_CURRENCY_DEFAULT = {
  id: "USD",
  payment_method_limits: [
    {
      id: "card",
      min: "10.00",
      max: "7500.00"
    },
    {
      id: "ach_bank_account",
      min: "10.00",
      max: "25000.00"
    }
  ]
};
var defaultState = {
  providers: ONRAMP_PROVIDERS,
  selectedProvider: null,
  error: null,
  purchaseCurrency: USDC_CURRENCY_DEFAULT,
  paymentCurrency: USD_CURRENCY_DEFAULT,
  purchaseCurrencies: [USDC_CURRENCY_DEFAULT],
  paymentCurrencies: [],
  quotesLoading: false
};
var state3 = proxy(defaultState);
var controller3 = {
  state: state3,
  subscribe(callback) {
    return subscribe(state3, () => callback(state3));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state3, key, callback);
  },
  setSelectedProvider(provider) {
    if (provider && provider.name === "meld") {
      const activeChain = ChainController.state.activeChain;
      const currency = activeChain === ConstantsUtil.CHAIN.SOLANA ? "SOL" : "USDC";
      const address = activeChain ? ChainController.state.chains.get(activeChain)?.accountState?.address ?? "" : "";
      const url = new URL(provider.url);
      url.searchParams.append("publicKey", MELD_PUBLIC_KEY);
      url.searchParams.append("destinationCurrencyCode", currency);
      url.searchParams.append("walletAddress", address);
      url.searchParams.append("externalCustomerId", OptionsController.state.projectId);
      state3.selectedProvider = { ...provider, url: url.toString() };
    } else {
      state3.selectedProvider = provider;
    }
  },
  setOnrampProviders(providers) {
    if (Array.isArray(providers) && providers.every((item) => typeof item === "string")) {
      const validOnramp = providers;
      const newProviders = ONRAMP_PROVIDERS.filter((provider) => validOnramp.includes(provider.name));
      state3.providers = newProviders;
    } else {
      state3.providers = [];
    }
  },
  setPurchaseCurrency(currency) {
    state3.purchaseCurrency = currency;
  },
  setPaymentCurrency(currency) {
    state3.paymentCurrency = currency;
  },
  setPurchaseAmount(amount) {
    OnRampController.state.purchaseAmount = amount;
  },
  setPaymentAmount(amount) {
    OnRampController.state.paymentAmount = amount;
  },
  async getAvailableCurrencies() {
    const options = await BlockchainApiController.getOnrampOptions();
    state3.purchaseCurrencies = options.purchaseCurrencies;
    state3.paymentCurrencies = options.paymentCurrencies;
    state3.paymentCurrency = options.paymentCurrencies[0] || USD_CURRENCY_DEFAULT;
    state3.purchaseCurrency = options.purchaseCurrencies[0] || USDC_CURRENCY_DEFAULT;
    await ApiController.fetchCurrencyImages(options.paymentCurrencies.map((currency) => currency.id));
    await ApiController.fetchTokenImages(options.purchaseCurrencies.map((currency) => currency.symbol));
  },
  async getQuote() {
    state3.quotesLoading = true;
    try {
      const quote = await BlockchainApiController.getOnrampQuote({
        purchaseCurrency: state3.purchaseCurrency,
        paymentCurrency: state3.paymentCurrency,
        amount: state3.paymentAmount?.toString() || "0",
        network: state3.purchaseCurrency?.symbol
      });
      state3.quotesLoading = false;
      state3.purchaseAmount = Number(quote?.purchaseAmount.amount);
      return quote;
    } catch (error) {
      state3.error = error.message;
      state3.quotesLoading = false;
      return null;
    } finally {
      state3.quotesLoading = false;
    }
  },
  resetState() {
    state3.selectedProvider = null;
    state3.error = null;
    state3.purchaseCurrency = USDC_CURRENCY_DEFAULT;
    state3.paymentCurrency = USD_CURRENCY_DEFAULT;
    state3.purchaseCurrencies = [USDC_CURRENCY_DEFAULT];
    state3.paymentCurrencies = [];
    state3.paymentAmount = void 0;
    state3.purchaseAmount = void 0;
    state3.quotesLoading = false;
  }
};
var OnRampController = withErrorBoundary(controller3);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/EnsUtil.js
var SLIP44_MSB = 2147483648;
var EnsUtil = {
  convertEVMChainIdToCoinType(chainId) {
    if (chainId >= SLIP44_MSB) {
      throw new Error("Invalid chainId");
    }
    return (SLIP44_MSB | chainId) >>> 0;
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EnsController.js
var state4 = proxy({
  suggestions: [],
  loading: false
});
var controller4 = {
  state: state4,
  subscribe(callback) {
    return subscribe(state4, () => callback(state4));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state4, key, callback);
  },
  async resolveName(name) {
    try {
      return await BlockchainApiController.lookupEnsName(name);
    } catch (e) {
      const error = e;
      throw new Error(error?.reasons?.[0]?.description || "Error resolving name");
    }
  },
  async isNameRegistered(name) {
    try {
      await BlockchainApiController.lookupEnsName(name);
      return true;
    } catch {
      return false;
    }
  },
  async getSuggestions(value) {
    try {
      state4.loading = true;
      state4.suggestions = [];
      const response = await BlockchainApiController.getEnsNameSuggestions(value);
      state4.suggestions = response.suggestions || [];
      return state4.suggestions;
    } catch (e) {
      const errorMessage = EnsController.parseEnsApiError(e, "Error fetching name suggestions");
      throw new Error(errorMessage);
    } finally {
      state4.loading = false;
    }
  },
  async getNamesForAddress(address) {
    try {
      const network = ChainController.state.activeCaipNetwork;
      if (!network) {
        return [];
      }
      const cachedEns = StorageUtil.getEnsFromCacheForAddress(address);
      if (cachedEns) {
        return cachedEns;
      }
      const response = await BlockchainApiController.reverseLookupEnsName({ address });
      StorageUtil.updateEnsCache({
        address,
        ens: response,
        timestamp: Date.now()
      });
      return response;
    } catch (e) {
      const errorMessage = EnsController.parseEnsApiError(e, "Error fetching names for address");
      throw new Error(errorMessage);
    }
  },
  async registerName(name) {
    const network = ChainController.state.activeCaipNetwork;
    const address = ChainController.getAccountData(network?.chainNamespace)?.address;
    const emailConnector = ConnectorController.getAuthConnector();
    if (!network) {
      throw new Error("Network not found");
    }
    if (!address || !emailConnector) {
      throw new Error("Address or auth connector not found");
    }
    state4.loading = true;
    try {
      const message = JSON.stringify({
        name,
        attributes: {},
        // Unix timestamp
        timestamp: Math.floor(Date.now() / 1e3)
      });
      RouterController.pushTransactionStack({
        onCancel() {
          RouterController.replace("RegisterAccountName");
        }
      });
      const signature = await ConnectionController.signMessage(message);
      state4.loading = false;
      const networkId = network.id;
      if (!networkId) {
        throw new Error("Network not found");
      }
      const coinType = EnsUtil.convertEVMChainIdToCoinType(Number(networkId));
      await BlockchainApiController.registerEnsName({
        coinType,
        address,
        signature,
        message
      });
      ChainController.setAccountProp("profileName", name, network.chainNamespace);
      StorageUtil.updateEnsCache({
        address,
        ens: [
          {
            name,
            registered_at: (/* @__PURE__ */ new Date()).toISOString(),
            updated_at: void 0,
            addresses: {},
            attributes: []
          }
        ],
        timestamp: Date.now()
      });
      RouterController.replace("RegisterAccountNameSuccess");
    } catch (e) {
      const errorMessage = EnsController.parseEnsApiError(e, `Error registering name ${name}`);
      RouterController.replace("RegisterAccountName");
      throw new Error(errorMessage);
    } finally {
      state4.loading = false;
    }
  },
  validateName(name) {
    return /^[a-zA-Z0-9-]{4,}$/u.test(name);
  },
  parseEnsApiError(error, defaultError) {
    const ensError = error;
    return ensError?.reasons?.[0]?.description || defaultError;
  }
};
var EnsController = withErrorBoundary(controller4);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/WalletConnectUtil.js
var DEFAULT_METHODS = {
  solana: [
    "solana_signMessage",
    "solana_signTransaction",
    "solana_requestAccounts",
    "solana_getAccounts",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction"
  ],
  eip155: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    // EIP-5792
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_sendCalls",
    "wallet_getCapabilities",
    // EIP-7715
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    //EIP-7811
    "wallet_getAssets"
  ],
  bip122: ["sendTransfer", "signMessage", "signPsbt", "getAccountAddresses"]
};
var WcHelpersUtil = {
  RPC_ERROR_CODE: {
    USER_REJECTED: 5e3,
    USER_REJECTED_METHODS: 5002
  },
  getMethodsByChainNamespace(chainNamespace) {
    return DEFAULT_METHODS[chainNamespace] || [];
  },
  createDefaultNamespace(chainNamespace) {
    return {
      methods: this.getMethodsByChainNamespace(chainNamespace),
      events: ["accountsChanged", "chainChanged"],
      chains: [],
      rpcMap: {}
    };
  },
  applyNamespaceOverrides(baseNamespaces, overrides) {
    if (!overrides) {
      return { ...baseNamespaces };
    }
    const result = { ...baseNamespaces };
    const namespacesToOverride = /* @__PURE__ */ new Set();
    if (overrides.methods) {
      Object.keys(overrides.methods).forEach((ns) => namespacesToOverride.add(ns));
    }
    if (overrides.chains) {
      Object.keys(overrides.chains).forEach((ns) => namespacesToOverride.add(ns));
    }
    if (overrides.events) {
      Object.keys(overrides.events).forEach((ns) => namespacesToOverride.add(ns));
    }
    if (overrides.rpcMap) {
      Object.keys(overrides.rpcMap).forEach((chainId) => {
        const [ns] = chainId.split(":");
        if (ns) {
          namespacesToOverride.add(ns);
        }
      });
    }
    namespacesToOverride.forEach((ns) => {
      if (!result[ns]) {
        result[ns] = this.createDefaultNamespace(ns);
      }
    });
    if (overrides.methods) {
      Object.entries(overrides.methods).forEach(([ns, methods]) => {
        if (result[ns]) {
          result[ns].methods = methods;
        }
      });
    }
    if (overrides.chains) {
      Object.entries(overrides.chains).forEach(([ns, chains]) => {
        if (result[ns]) {
          result[ns].chains = chains;
        }
      });
    }
    if (overrides.events) {
      Object.entries(overrides.events).forEach(([ns, events]) => {
        if (result[ns]) {
          result[ns].events = events;
        }
      });
    }
    if (overrides.rpcMap) {
      const processedNamespaces = /* @__PURE__ */ new Set();
      Object.entries(overrides.rpcMap).forEach(([chainId, rpcUrl]) => {
        const [ns, id] = chainId.split(":");
        if (!ns || !id || !result[ns]) {
          return;
        }
        if (!result[ns].rpcMap) {
          result[ns].rpcMap = {};
        }
        if (!processedNamespaces.has(ns)) {
          result[ns].rpcMap = {};
          processedNamespaces.add(ns);
        }
        result[ns].rpcMap[id] = rpcUrl;
      });
    }
    return result;
  },
  createNamespaces(caipNetworks, configOverride) {
    const defaultNamespaces = caipNetworks.reduce((acc, chain) => {
      const { id, chainNamespace, rpcUrls } = chain;
      const rpcUrl = rpcUrls.default.http[0];
      if (!acc[chainNamespace]) {
        acc[chainNamespace] = this.createDefaultNamespace(chainNamespace);
      }
      const caipNetworkId = `${chainNamespace}:${id}`;
      const namespace = acc[chainNamespace];
      namespace.chains.push(caipNetworkId);
      switch (caipNetworkId) {
        case "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp":
          namespace.chains.push("solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ");
          break;
        case "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1":
          namespace.chains.push("solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K");
          break;
        default:
      }
      if (namespace?.rpcMap && rpcUrl) {
        namespace.rpcMap[id] = rpcUrl;
      }
      return acc;
    }, {});
    return this.applyNamespaceOverrides(defaultNamespaces, configOverride);
  },
  resolveReownName: async (name) => {
    const wcNameAddress = await EnsController.resolveName(name);
    const networkNameAddresses = Object.values(wcNameAddress?.addresses) || [];
    return networkNameAddresses[0]?.address || false;
  },
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const [chainNamespace, chainId] = account.split(":");
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  },
  isSessionEventData(data) {
    return typeof data === "object" && data !== null && "id" in data && "topic" in data && "params" in data && typeof data.params === "object" && data.params !== null && "chainId" in data.params && "event" in data.params && typeof data.params.event === "object" && data.params.event !== null;
  },
  isUserRejectedRequestError(error) {
    try {
      if (typeof error === "object" && error !== null) {
        const objErr = error;
        const hasCode = typeof objErr["code"] === "number";
        const hasUserRejectedMethods = hasCode && objErr["code"] === WcHelpersUtil.RPC_ERROR_CODE.USER_REJECTED_METHODS;
        const hasUserRejected = hasCode && objErr["code"] === WcHelpersUtil.RPC_ERROR_CODE.USER_REJECTED;
        return hasUserRejectedMethods || hasUserRejected;
      }
      return false;
    } catch {
      return false;
    }
  },
  isOriginAllowed(currentOrigin, allowedPatterns, defaultAllowedOrigins) {
    for (const pattern of [...allowedPatterns, ...defaultAllowedOrigins]) {
      if (pattern.includes("*")) {
        const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
        const regexString = `^${escapedPattern.replace(/\\\*/gu, ".*")}$`;
        const regex = new RegExp(regexString, "u");
        if (regex.test(currentOrigin)) {
          return true;
        }
      } else {
        try {
          if (new URL(pattern).origin === currentOrigin) {
            return true;
          }
        } catch (e) {
          if (pattern === currentOrigin) {
            return true;
          }
        }
      }
    }
    return false;
  },
  listenWcProvider({ universalProvider, namespace, onConnect, onDisconnect, onAccountsChanged, onChainChanged, onDisplayUri }) {
    if (onConnect) {
      universalProvider.on("connect", () => {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(universalProvider, namespace);
        onConnect(accounts);
      });
    }
    if (onDisconnect) {
      universalProvider.on("disconnect", () => {
        onDisconnect();
      });
    }
    if (onAccountsChanged) {
      universalProvider.on("accountsChanged", (accounts) => {
        try {
          const allAccounts = universalProvider.session?.namespaces?.[namespace]?.accounts || [];
          const defaultChain = universalProvider.rpcProviders?.[namespace]?.getDefaultChain();
          const parsedAccounts = accounts.map((account) => {
            const caipAccount = allAccounts.find((acc) => acc.includes(`${namespace}:${defaultChain}:${account}`));
            if (!caipAccount) {
              return void 0;
            }
            const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(caipAccount);
            return {
              address: account,
              chainId,
              chainNamespace
            };
          }).filter((account) => account !== void 0);
          if (parsedAccounts.length > 0) {
            onAccountsChanged(parsedAccounts);
          }
        } catch (error) {
          console.warn("Failed to parse accounts for namespace on accountsChanged event", namespace, accounts, error);
        }
      });
    }
    if (onChainChanged) {
      universalProvider.on("chainChanged", (chainId) => {
        onChainChanged(chainId);
      });
    }
    if (onDisplayUri) {
      universalProvider.on("display_uri", (uri) => {
        onDisplayUri(uri);
      });
    }
  },
  getWalletConnectAccounts(universalProvider, namespace) {
    const accountsAdded = /* @__PURE__ */ new Set();
    const accounts = universalProvider?.session?.namespaces?.[namespace]?.accounts?.map((account) => ParseUtil.parseCaipAddress(account)).filter(({ address }) => {
      if (accountsAdded.has(address.toLowerCase())) {
        return false;
      }
      accountsAdded.add(address.toLowerCase());
      return true;
    });
    if (accounts && accounts.length > 0) {
      return accounts;
    }
    return [];
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AdapterController/ChainAdapterBlueprint.js
var IGNORED_CONNECTOR_IDS_FOR_LISTENER = [
  ConstantsUtil.CONNECTOR_ID.AUTH,
  ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT
];
var AdapterBlueprint = class {
  /**
   * Creates an instance of AdapterBlueprint.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  constructor(params) {
    this.availableConnectors = [];
    this.availableConnections = [];
    this.providerHandlers = {};
    this.eventListeners = /* @__PURE__ */ new Map();
    this.getCaipNetworks = (namespace) => ChainController.getCaipNetworks(namespace);
    this.getConnectorId = (namespace) => ConnectorController.getConnectorId(namespace);
    if (params) {
      this.construct(params);
    }
  }
  /**
   * Initializes the adapter with the given parameters.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  construct(params) {
    this.projectId = params.projectId;
    this.namespace = params.namespace;
    this.adapterType = params.adapterType;
  }
  /**
   * Gets the available connectors.
   * @returns {Connector[]} An array of available connectors
   */
  get connectors() {
    return this.availableConnectors;
  }
  /**
   * Gets the available connections.
   * @returns {Connection[]} An array of available connections
   */
  get connections() {
    return this.availableConnections;
  }
  /**
   * Gets the supported networks.
   * @returns {CaipNetwork[]} An array of supported networks
   */
  get networks() {
    return this.getCaipNetworks(this.namespace);
  }
  /**
   * Handles the auth connected event.
   * @param {W3mFrameTypes.Responses['FrameGetUserResponse']} user - The user response
   */
  onAuthConnected({ accounts, chainId }) {
    const caipNetwork = this.getCaipNetworks().filter((n2) => n2.chainNamespace === this.namespace).find((n2) => n2.id.toString() === chainId?.toString());
    if (accounts && caipNetwork) {
      this.addConnection({
        connectorId: ConstantsUtil.CONNECTOR_ID.AUTH,
        accounts,
        caipNetwork
      });
    }
  }
  /**
   * Sets the auth provider.
   * @param {W3mFrameProvider} authProvider - The auth provider instance
   */
  setAuthProvider(authProvider) {
    authProvider.onConnect(this.onAuthConnected.bind(this));
    authProvider.onSocialConnected(this.onAuthConnected.bind(this));
    this.addConnector({
      id: ConstantsUtil.CONNECTOR_ID.AUTH,
      type: "AUTH",
      name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
      provider: authProvider,
      imageId: void 0,
      chain: this.namespace,
      chains: []
    });
  }
  /**
   * Adds one or more connectors to the available connectors list.
   * @param {...Connector} connectors - The connectors to add
   */
  addConnector(...connectors) {
    const connectorsAdded = /* @__PURE__ */ new Set();
    this.availableConnectors = [...connectors, ...this.availableConnectors].filter((connector) => {
      if (connectorsAdded.has(connector.id)) {
        return false;
      }
      connectorsAdded.add(connector.id);
      return true;
    });
    this.emit("connectors", this.availableConnectors);
  }
  /**
   * Adds connections to the available connections list
   * @param {...Connection} connections - The connections to add
   */
  addConnection(...connections) {
    const connectionsAdded = /* @__PURE__ */ new Set();
    this.availableConnections = [...connections, ...this.availableConnections].filter((connection) => {
      if (connectionsAdded.has(connection.connectorId.toLowerCase())) {
        return false;
      }
      connectionsAdded.add(connection.connectorId.toLowerCase());
      return true;
    });
    this.emit("connections", this.availableConnections);
  }
  /**
   * Deletes a connection from the available connections list
   * @param {string} connectorId - The connector ID of the connection to delete
   */
  deleteConnection(connectorId) {
    this.availableConnections = this.availableConnections.filter((c) => c.connectorId.toLowerCase() !== connectorId.toLowerCase());
    this.emit("connections", this.availableConnections);
  }
  /**
   * Clears all connections from the available connections list
   * @param {boolean} emit - Whether to emit the connections event
   */
  clearConnections(emit = false) {
    this.availableConnections = [];
    if (emit) {
      this.emit("connections", this.availableConnections);
    }
  }
  setStatus(status, chainNamespace) {
    ChainController.setAccountProp("status", status, chainNamespace);
  }
  /**
   * Adds an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be called when the event is emitted
   */
  on(eventName, callback) {
    if (!this.eventListeners.has(eventName)) {
      this.eventListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    this.eventListeners.get(eventName)?.add(callback);
  }
  /**
   * Removes an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be removed
   */
  off(eventName, callback) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.delete(callback);
    }
  }
  /**
   * Removes all event listeners.
   */
  removeAllEventListeners() {
    this.eventListeners.forEach((listeners) => {
      listeners.clear();
    });
  }
  /**
   * Emits an event with the given name and optional data.
   * @template T
   * @param {T} eventName - The name of the event to emit
   * @param {EventData[T]} [data] - The optional data to be passed to the event listeners
   */
  emit(eventName, data) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.forEach((callback) => callback(data));
    }
  }
  /**
   * Connects to WalletConnect.
   * @param {number | string} [_chainId] - Optional chain ID to connect to
   */
  async connectWalletConnect(_chainId) {
    try {
      const connector = this.getWalletConnectConnector();
      const result = await connector.connectWalletConnect();
      return { clientId: result.clientId };
    } catch (err) {
      if (WcHelpersUtil.isUserRejectedRequestError(err)) {
        throw new UserRejectedRequestError(err);
      }
      throw err;
    }
  }
  /**
   * Switches the network.
   * @param {AdapterBlueprint.SwitchNetworkParams} params - Network switching parameters
   */
  async switchNetwork(params) {
    const { caipNetwork } = params;
    const providerType = ProviderController.getProviderId(caipNetwork.chainNamespace);
    const provider = ProviderController.getProvider(caipNetwork.chainNamespace);
    if (!provider) {
      throw new Error("Provider not found");
    }
    if (providerType === "WALLET_CONNECT") {
      const walletConnectProvider = provider;
      walletConnectProvider.setDefaultChain(caipNetwork.caipNetworkId);
      return;
    }
    if (providerType === "AUTH") {
      const authProvider = ConnectorController.getAuthConnector()?.provider;
      if (!authProvider) {
        throw new Error("Auth provider not found");
      }
      const preferredAccountType = getPreferredAccountType(caipNetwork.chainNamespace);
      await authProvider.switchNetwork({ chainId: caipNetwork.caipNetworkId });
      const user = await authProvider.getUser({
        chainId: caipNetwork.caipNetworkId,
        preferredAccountType
      });
      this.emit("switchNetwork", user);
    }
  }
  getWalletConnectConnector() {
    const connector = this.connectors.find((c) => c.id === "walletConnect");
    if (!connector) {
      throw new Error("WalletConnectConnector not found");
    }
    return connector;
  }
  /**
   * Handles connect event for a specific connector.
   * @param {string[]} accounts - The accounts that changed
   * @param {string} connectorId - The ID of the connector
   */
  onConnect(accounts, connectorId) {
    if (accounts.length > 0) {
      const { address, chainId } = CoreHelperUtil.getAccount(accounts[0]);
      const caipNetwork = this.getCaipNetworks().filter((n2) => n2.chainNamespace === this.namespace).find((n2) => n2.id.toString() === chainId?.toString());
      const connector = this.connectors.find((c) => c.id === connectorId);
      if (address) {
        this.emit("accountChanged", {
          address,
          chainId,
          connector
        });
        this.addConnection({
          connectorId,
          accounts: accounts.map((_account) => {
            const { address: address2 } = CoreHelperUtil.getAccount(_account);
            return { address: address2 };
          }),
          caipNetwork
        });
      }
    }
  }
  /**
   * Handles accounts changed event for a specific connector.
   * @param {string[]} accounts - The accounts that changed
   * @param {string} connectorId - The ID of the connector
   */
  onAccountsChanged(accounts, connectorId, disconnectIfNoAccounts = true) {
    if (accounts.length > 0) {
      const { address } = CoreHelperUtil.getAccount(accounts[0]);
      const connection = this.getConnection({
        connectorId,
        connections: this.connections,
        connectors: this.connectors
      });
      if (address && this.getConnectorId(ConstantsUtil.CHAIN.EVM)?.toLowerCase() === connectorId.toLowerCase()) {
        this.emit("accountChanged", {
          address,
          chainId: connection?.caipNetwork?.id,
          connector: connection?.connector
        });
      }
      this.addConnection({
        connectorId,
        accounts: accounts.map((_account) => {
          const { address: address2 } = CoreHelperUtil.getAccount(_account);
          return { address: address2 };
        }),
        caipNetwork: connection?.caipNetwork
      });
    } else if (disconnectIfNoAccounts) {
      this.onDisconnect(connectorId);
    }
  }
  /**
   * Handles disconnect event for a specific connector.
   * @param {string} connectorId - The ID of the connector
   */
  onDisconnect(connectorId) {
    this.removeProviderListeners(connectorId);
    this.deleteConnection(connectorId);
    if (this.getConnectorId(ConstantsUtil.CHAIN.EVM)?.toLowerCase() === connectorId.toLowerCase()) {
      this.emitFirstAvailableConnection();
    }
    if (this.connections.length === 0) {
      this.emit("disconnect");
    }
  }
  /**
   * Handles chain changed event for a specific connector.
   * @param {string} chainId - The ID of the chain that changed
   * @param {string} connectorId - The ID of the connector
   */
  onChainChanged(chainId, connectorId) {
    const formattedChainId = typeof chainId === "string" && chainId.startsWith("0x") ? parseInt(chainId, 16).toString() : chainId.toString();
    const connection = this.getConnection({
      connectorId,
      connections: this.connections,
      connectors: this.connectors
    });
    const caipNetwork = this.getCaipNetworks().filter((n2) => n2.chainNamespace === this.namespace).find((n2) => n2.id.toString() === formattedChainId);
    if (connection) {
      this.addConnection({
        connectorId,
        accounts: connection.accounts,
        caipNetwork
      });
    }
    if (this.getConnectorId(ConstantsUtil.CHAIN.EVM)?.toLowerCase() === connectorId.toLowerCase()) {
      this.emit("switchNetwork", { chainId: formattedChainId });
    }
  }
  /**
   * Listens to provider events for a specific connector.
   * @param {string} connectorId - The ID of the connector
   * @param {Provider | CombinedProvider} provider - The provider to listen to
   */
  listenProviderEvents(connectorId, provider) {
    if (IGNORED_CONNECTOR_IDS_FOR_LISTENER.includes(connectorId)) {
      return;
    }
    const accountsChangedHandler = (accounts) => this.onAccountsChanged(accounts, connectorId);
    const chainChangedHandler = (chainId) => this.onChainChanged(chainId, connectorId);
    const disconnectHandler = () => this.onDisconnect(connectorId);
    if (!this.providerHandlers[connectorId]) {
      provider.on("disconnect", disconnectHandler);
      provider.on("accountsChanged", accountsChangedHandler);
      provider.on("chainChanged", chainChangedHandler);
      this.providerHandlers[connectorId] = {
        provider,
        disconnect: disconnectHandler,
        accountsChanged: accountsChangedHandler,
        chainChanged: chainChangedHandler
      };
    }
  }
  /**
   * Removes provider listeners for a specific connector.
   * @param {string} connectorId - The ID of the connector
   */
  removeProviderListeners(connectorId) {
    if (this.providerHandlers[connectorId]) {
      const { provider, disconnect, accountsChanged, chainChanged } = this.providerHandlers[connectorId];
      provider.removeListener("disconnect", disconnect);
      provider.removeListener("accountsChanged", accountsChanged);
      provider.removeListener("chainChanged", chainChanged);
      this.providerHandlers[connectorId] = null;
    }
  }
  /**
   * Emits the first available connection.
   */
  emitFirstAvailableConnection() {
    const connection = this.getConnection({
      connections: this.connections,
      connectors: this.connectors
    });
    if (connection) {
      const [account] = connection.accounts;
      this.emit("accountChanged", {
        address: account?.address,
        chainId: connection.caipNetwork?.id,
        connector: connection.connector
      });
    }
  }
  /**
   * Gets a connection based on provided parameters.
   * If connectorId is provided, returns connection for that specific connector.
   * Otherwise, returns the first available valid connection.
   *
   * @param params - Connection parameters
   * @param params.address - Optional address to filter by
   * @param params.connectorId - Optional connector ID to filter by
   * @param params.connections - List of available connections
   * @param params.connectors - List of available connectors
   * @returns Connection or null if none found
   */
  getConnection({ address, connectorId, connections, connectors }) {
    if (connectorId) {
      const connection = connections.find((c) => c.connectorId.toLowerCase() === connectorId.toLowerCase());
      if (!connection) {
        return null;
      }
      const connector = connectors.find((c) => c.id.toLowerCase() === connection.connectorId.toLowerCase());
      const account = address ? connection.accounts.find((a) => a.address.toLowerCase() === address.toLowerCase()) : connection.accounts[0];
      return { ...connection, account, connector };
    }
    const validConnection = connections.find((c) => c.accounts.length > 0 && connectors.some((conn) => conn.id.toLowerCase() === c.connectorId.toLowerCase()));
    if (validConnection) {
      const [account] = validConnection.accounts;
      const connector = connectors.find((c) => c.id.toLowerCase() === validConnection.connectorId.toLowerCase());
      return {
        ...validConnection,
        account,
        connector
      };
    }
    return null;
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AdapterController/WalletConnectConnector.js
var WalletConnectConnector = class {
  constructor({ provider, namespace }) {
    this.id = ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
    this.name = "WalletConnect";
    this.type = "WALLET_CONNECT";
    this.imageId = "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400";
    this.getCaipNetworks = ChainController.getCaipNetworks.bind(ChainController);
    this.caipNetworks = this.getCaipNetworks();
    this.provider = provider;
    this.chain = namespace;
  }
  get chains() {
    return this.getCaipNetworks();
  }
  async connectWalletConnect() {
    const isAuthenticated = await this.authenticate();
    if (!isAuthenticated) {
      const caipNetworks = this.getCaipNetworks();
      const universalProviderConfigOverride = OptionsController.state.universalProviderConfigOverride;
      const namespaces = WcHelpersUtil.createNamespaces(caipNetworks, universalProviderConfigOverride);
      await this.provider.connect({ optionalNamespaces: namespaces });
    }
    return {
      clientId: await this.provider.client.core.crypto.getClientId(),
      session: this.provider.session
    };
  }
  async disconnect() {
    await this.provider.disconnect();
  }
  async authenticate() {
    const chains = this.chains.map((network) => network.caipNetworkId);
    return SIWXUtil.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains,
      methods: OPTIONAL_METHODS
    });
  }
};
var OPTIONAL_METHODS = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode",
  // EIP-5792
  "wallet_getCallsStatus",
  "wallet_sendCalls",
  "wallet_getCapabilities",
  // EIP-7715
  "wallet_grantPermissions",
  "wallet_revokePermissions",
  //EIP-7811
  "wallet_getAssets"
];

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TooltipController.js
var state5 = proxy({
  message: "",
  open: false,
  triggerRect: {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  },
  variant: "shade"
});
var controller5 = {
  state: state5,
  subscribe(callback) {
    return subscribe(state5, () => callback(state5));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state5, key, callback);
  },
  showTooltip({ message, triggerRect, variant }) {
    state5.open = true;
    state5.message = message;
    state5.triggerRect = triggerRect;
    state5.variant = variant;
  },
  hide() {
    state5.open = false;
    state5.message = "";
    state5.triggerRect = {
      width: 0,
      height: 0,
      top: 0,
      left: 0
    };
  }
};
var TooltipController = withErrorBoundary(controller5);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OptionsStateController.js
var state6 = proxy({
  isLegalCheckboxChecked: false
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ExchangeUtil.js
var baseUSDC = {
  network: "eip155:8453",
  asset: "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",
  metadata: {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6
  }
};
var baseSepoliaUSDC = {
  network: "eip155:84532",
  asset: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
  metadata: {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ExchangeController.js
var DEFAULT_STATE = {
  paymentAsset: null,
  amount: null,
  tokenAmount: 0,
  priceLoading: false,
  error: null,
  exchanges: [],
  isLoading: false,
  currentPayment: void 0,
  isPaymentInProgress: false,
  paymentId: "",
  assets: []
};
var state7 = proxy(DEFAULT_STATE);

// node_modules/lit-html/development/lit-html.js
var DEV_MODE = true;
var ENABLE_EXTRA_SECURITY_HOOKS = true;
var ENABLE_SHADYDOM_NOPATCH = true;
var NODE_MODE = false;
var global2 = globalThis;
var debugLogEvent = DEV_MODE ? (event) => {
  const shouldEmit = global2.emitLitDebugLogEvents;
  if (!shouldEmit) {
    return;
  }
  global2.dispatchEvent(new CustomEvent("lit-debug", {
    detail: event
  }));
} : void 0;
var debugLogRenderId = 0;
var issueWarning;
if (DEV_MODE) {
  global2.litIssuedWarnings ??= /* @__PURE__ */ new Set();
  issueWarning = (code, warning) => {
    warning += code ? ` See https://lit.dev/msg/${code} for more information.` : "";
    if (!global2.litIssuedWarnings.has(warning) && !global2.litIssuedWarnings.has(code)) {
      console.warn(warning);
      global2.litIssuedWarnings.add(warning);
    }
  };
  queueMicrotask(() => {
    issueWarning("dev-mode", `Lit is in dev mode. Not recommended for production!`);
  });
}
var wrap = ENABLE_SHADYDOM_NOPATCH && global2.ShadyDOM?.inUse && global2.ShadyDOM?.noPatch === true ? global2.ShadyDOM.wrap : (node) => node;
var trustedTypes = global2.trustedTypes;
var policy = trustedTypes ? trustedTypes.createPolicy("lit-html", {
  createHTML: (s) => s
}) : void 0;
var identityFunction = (value) => value;
var noopSanitizer = (_node, _name, _type) => identityFunction;
var setSanitizer = (newSanitizer) => {
  if (!ENABLE_EXTRA_SECURITY_HOOKS) {
    return;
  }
  if (sanitizerFactoryInternal !== noopSanitizer) {
    throw new Error(`Attempted to overwrite existing lit-html security policy. setSanitizeDOMValueFactory should be called at most once.`);
  }
  sanitizerFactoryInternal = newSanitizer;
};
var _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {
  sanitizerFactoryInternal = noopSanitizer;
};
var createSanitizer = (node, name, type) => {
  return sanitizerFactoryInternal(node, name, type);
};
var boundAttributeSuffix = "$lit$";
var marker = `lit$${Math.random().toFixed(9).slice(2)}$`;
var markerMatch = "?" + marker;
var nodeMarker = `<${markerMatch}>`;
var d2 = NODE_MODE && global2.document === void 0 ? {
  createTreeWalker() {
    return {};
  }
} : document;
var createMarker = () => d2.createComment("");
var isPrimitive = (value) => value === null || typeof value != "object" && typeof value != "function";
var isArray = Array.isArray;
var isIterable = (value) => isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
typeof value?.[Symbol.iterator] === "function";
var SPACE_CHAR = `[ 	
\f\r]`;
var ATTR_VALUE_CHAR = `[^ 	
\f\r"'\`<>=]`;
var NAME_CHAR = `[^\\s"'>=/]`;
var textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var COMMENT_START = 1;
var TAG_NAME = 2;
var DYNAMIC_TAG_NAME = 3;
var commentEndRegex = /-->/g;
var comment2EndRegex = />/g;
var tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`, "g");
var ENTIRE_MATCH = 0;
var ATTRIBUTE_NAME = 1;
var SPACES_AND_EQUALS = 2;
var QUOTE_CHAR = 3;
var singleQuoteAttrEndRegex = /'/g;
var doubleQuoteAttrEndRegex = /"/g;
var rawTextElement = /^(?:script|style|textarea|title)$/i;
var HTML_RESULT = 1;
var SVG_RESULT = 2;
var MATHML_RESULT = 3;
var ATTRIBUTE_PART = 1;
var CHILD_PART = 2;
var PROPERTY_PART = 3;
var BOOLEAN_ATTRIBUTE_PART = 4;
var EVENT_PART = 5;
var ELEMENT_PART = 6;
var COMMENT_PART = 7;
var tag = (type) => (strings, ...values) => {
  if (DEV_MODE && strings.some((s) => s === void 0)) {
    console.warn("Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.");
  }
  if (DEV_MODE) {
    if (values.some((val) => val?.["_$litStatic$"])) {
      issueWarning("", `Static values 'literal' or 'unsafeStatic' cannot be used as values to non-static templates.
Please use the static 'html' tag function. See https://lit.dev/docs/templates/expressions/#static-expressions`);
    }
  }
  return {
    // This property needs to remain unminified.
    ["_$litType$"]: type,
    strings,
    values
  };
};
var html = tag(HTML_RESULT);
var svg = tag(SVG_RESULT);
var mathml = tag(MATHML_RESULT);
var noChange = Symbol.for("lit-noChange");
var nothing = Symbol.for("lit-nothing");
var templateCache = /* @__PURE__ */ new WeakMap();
var walker = d2.createTreeWalker(
  d2,
  129
  /* NodeFilter.SHOW_{ELEMENT|COMMENT} */
);
var sanitizerFactoryInternal = noopSanitizer;
function trustFromTemplateString(tsa, stringFromTSA) {
  if (!isArray(tsa) || !tsa.hasOwnProperty("raw")) {
    let message = "invalid template strings array";
    if (DEV_MODE) {
      message = `
          Internal Error: expected template strings to be an array
          with a 'raw' field. Faking a template strings array by
          calling html or svg like an ordinary function is effectively
          the same as calling unsafeHtml and can lead to major security
          issues, e.g. opening your code up to XSS attacks.
          If you're using the html or svg tagged template functions normally
          and still seeing this error, please file a bug at
          https://github.com/lit/lit/issues/new?template=bug_report.md
          and include information about your build tooling, if any.
        `.trim().replace(/\n */g, "\n");
    }
    throw new Error(message);
  }
  return policy !== void 0 ? policy.createHTML(stringFromTSA) : stringFromTSA;
}
var getTemplateHtml = (strings, type) => {
  const l2 = strings.length - 1;
  const attrNames = [];
  let html2 = type === SVG_RESULT ? "<svg>" : type === MATHML_RESULT ? "<math>" : "";
  let rawTextEndRegex;
  let regex = textEndRegex;
  for (let i2 = 0; i2 < l2; i2++) {
    const s = strings[i2];
    let attrNameEndIndex = -1;
    let attrName;
    let lastIndex = 0;
    let match;
    while (lastIndex < s.length) {
      regex.lastIndex = lastIndex;
      match = regex.exec(s);
      if (match === null) {
        break;
      }
      lastIndex = regex.lastIndex;
      if (regex === textEndRegex) {
        if (match[COMMENT_START] === "!--") {
          regex = commentEndRegex;
        } else if (match[COMMENT_START] !== void 0) {
          regex = comment2EndRegex;
        } else if (match[TAG_NAME] !== void 0) {
          if (rawTextElement.test(match[TAG_NAME])) {
            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, "g");
          }
          regex = tagEndRegex;
        } else if (match[DYNAMIC_TAG_NAME] !== void 0) {
          if (DEV_MODE) {
            throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions");
          }
          regex = tagEndRegex;
        }
      } else if (regex === tagEndRegex) {
        if (match[ENTIRE_MATCH] === ">") {
          regex = rawTextEndRegex ?? textEndRegex;
          attrNameEndIndex = -1;
        } else if (match[ATTRIBUTE_NAME] === void 0) {
          attrNameEndIndex = -2;
        } else {
          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;
          attrName = match[ATTRIBUTE_NAME];
          regex = match[QUOTE_CHAR] === void 0 ? tagEndRegex : match[QUOTE_CHAR] === '"' ? doubleQuoteAttrEndRegex : singleQuoteAttrEndRegex;
        }
      } else if (regex === doubleQuoteAttrEndRegex || regex === singleQuoteAttrEndRegex) {
        regex = tagEndRegex;
      } else if (regex === commentEndRegex || regex === comment2EndRegex) {
        regex = textEndRegex;
      } else {
        regex = tagEndRegex;
        rawTextEndRegex = void 0;
      }
    }
    if (DEV_MODE) {
      console.assert(attrNameEndIndex === -1 || regex === tagEndRegex || regex === singleQuoteAttrEndRegex || regex === doubleQuoteAttrEndRegex, "unexpected parse state B");
    }
    const end = regex === tagEndRegex && strings[i2 + 1].startsWith("/>") ? " " : "";
    html2 += regex === textEndRegex ? s + nodeMarker : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s.slice(0, attrNameEndIndex) + boundAttributeSuffix + s.slice(attrNameEndIndex)) + marker + end : s + marker + (attrNameEndIndex === -2 ? i2 : end);
  }
  const htmlResult = html2 + (strings[l2] || "<?>") + (type === SVG_RESULT ? "</svg>" : type === MATHML_RESULT ? "</math>" : "");
  return [trustFromTemplateString(strings, htmlResult), attrNames];
};
var Template = class _Template {
  constructor({ strings, ["_$litType$"]: type }, options) {
    this.parts = [];
    let node;
    let nodeIndex = 0;
    let attrNameIndex = 0;
    const partCount = strings.length - 1;
    const parts = this.parts;
    const [html2, attrNames] = getTemplateHtml(strings, type);
    this.el = _Template.createElement(html2, options);
    walker.currentNode = this.el.content;
    if (type === SVG_RESULT || type === MATHML_RESULT) {
      const wrapper = this.el.content.firstChild;
      wrapper.replaceWith(...wrapper.childNodes);
    }
    while ((node = walker.nextNode()) !== null && parts.length < partCount) {
      if (node.nodeType === 1) {
        if (DEV_MODE) {
          const tag2 = node.localName;
          if (/^(?:textarea|template)$/i.test(tag2) && node.innerHTML.includes(marker)) {
            const m2 = `Expressions are not supported inside \`${tag2}\` elements. See https://lit.dev/msg/expression-in-${tag2} for more information.`;
            if (tag2 === "template") {
              throw new Error(m2);
            } else
              issueWarning("", m2);
          }
        }
        if (node.hasAttributes()) {
          for (const name of node.getAttributeNames()) {
            if (name.endsWith(boundAttributeSuffix)) {
              const realName = attrNames[attrNameIndex++];
              const value = node.getAttribute(name);
              const statics = value.split(marker);
              const m2 = /([.?@])?(.*)/.exec(realName);
              parts.push({
                type: ATTRIBUTE_PART,
                index: nodeIndex,
                name: m2[2],
                strings: statics,
                ctor: m2[1] === "." ? PropertyPart : m2[1] === "?" ? BooleanAttributePart : m2[1] === "@" ? EventPart : AttributePart
              });
              node.removeAttribute(name);
            } else if (name.startsWith(marker)) {
              parts.push({
                type: ELEMENT_PART,
                index: nodeIndex
              });
              node.removeAttribute(name);
            }
          }
        }
        if (rawTextElement.test(node.tagName)) {
          const strings2 = node.textContent.split(marker);
          const lastIndex = strings2.length - 1;
          if (lastIndex > 0) {
            node.textContent = trustedTypes ? trustedTypes.emptyScript : "";
            for (let i2 = 0; i2 < lastIndex; i2++) {
              node.append(strings2[i2], createMarker());
              walker.nextNode();
              parts.push({ type: CHILD_PART, index: ++nodeIndex });
            }
            node.append(strings2[lastIndex], createMarker());
          }
        }
      } else if (node.nodeType === 8) {
        const data = node.data;
        if (data === markerMatch) {
          parts.push({ type: CHILD_PART, index: nodeIndex });
        } else {
          let i2 = -1;
          while ((i2 = node.data.indexOf(marker, i2 + 1)) !== -1) {
            parts.push({ type: COMMENT_PART, index: nodeIndex });
            i2 += marker.length - 1;
          }
        }
      }
      nodeIndex++;
    }
    if (DEV_MODE) {
      if (attrNames.length !== attrNameIndex) {
        throw new Error(`Detected duplicate attribute bindings. This occurs if your template has duplicate attributes on an element tag. For example "<input ?disabled=\${true} ?disabled=\${false}>" contains a duplicate "disabled" attribute. The error was detected in the following template: 
\`` + strings.join("${...}") + "`");
      }
    }
    debugLogEvent && debugLogEvent({
      kind: "template prep",
      template: this,
      clonableTemplate: this.el,
      parts: this.parts,
      strings
    });
  }
  // Overridden via `litHtmlPolyfillSupport` to provide platform support.
  /** @nocollapse */
  static createElement(html2, _options) {
    const el = d2.createElement("template");
    el.innerHTML = html2;
    return el;
  }
};
function resolveDirective(part, value, parent = part, attributeIndex) {
  if (value === noChange) {
    return value;
  }
  let currentDirective = attributeIndex !== void 0 ? parent.__directives?.[attributeIndex] : parent.__directive;
  const nextDirectiveConstructor = isPrimitive(value) ? void 0 : (
    // This property needs to remain unminified.
    value["_$litDirective$"]
  );
  if (currentDirective?.constructor !== nextDirectiveConstructor) {
    currentDirective?.["_$notifyDirectiveConnectionChanged"]?.(false);
    if (nextDirectiveConstructor === void 0) {
      currentDirective = void 0;
    } else {
      currentDirective = new nextDirectiveConstructor(part);
      currentDirective._$initialize(part, parent, attributeIndex);
    }
    if (attributeIndex !== void 0) {
      (parent.__directives ??= [])[attributeIndex] = currentDirective;
    } else {
      parent.__directive = currentDirective;
    }
  }
  if (currentDirective !== void 0) {
    value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
  }
  return value;
}
var TemplateInstance = class {
  constructor(template, parent) {
    this._$parts = [];
    this._$disconnectableChildren = void 0;
    this._$template = template;
    this._$parent = parent;
  }
  // Called by ChildPart parentNode getter
  get parentNode() {
    return this._$parent.parentNode;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  // This method is separate from the constructor because we need to return a
  // DocumentFragment and we don't want to hold onto it with an instance field.
  _clone(options) {
    const { el: { content }, parts } = this._$template;
    const fragment = (options?.creationScope ?? d2).importNode(content, true);
    walker.currentNode = fragment;
    let node = walker.nextNode();
    let nodeIndex = 0;
    let partIndex = 0;
    let templatePart = parts[0];
    while (templatePart !== void 0) {
      if (nodeIndex === templatePart.index) {
        let part;
        if (templatePart.type === CHILD_PART) {
          part = new ChildPart(node, node.nextSibling, this, options);
        } else if (templatePart.type === ATTRIBUTE_PART) {
          part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
        } else if (templatePart.type === ELEMENT_PART) {
          part = new ElementPart(node, this, options);
        }
        this._$parts.push(part);
        templatePart = parts[++partIndex];
      }
      if (nodeIndex !== templatePart?.index) {
        node = walker.nextNode();
        nodeIndex++;
      }
    }
    walker.currentNode = d2;
    return fragment;
  }
  _update(values) {
    let i2 = 0;
    for (const part of this._$parts) {
      if (part !== void 0) {
        debugLogEvent && debugLogEvent({
          kind: "set part",
          part,
          value: values[i2],
          valueIndex: i2,
          values,
          templateInstance: this
        });
        if (part.strings !== void 0) {
          part._$setValue(values, part, i2);
          i2 += part.strings.length - 2;
        } else {
          part._$setValue(values[i2]);
        }
      }
      i2++;
    }
  }
};
var ChildPart = class _ChildPart {
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent?._$isConnected ?? this.__isConnected;
  }
  constructor(startNode, endNode, parent, options) {
    this.type = CHILD_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this._$startNode = startNode;
    this._$endNode = endNode;
    this._$parent = parent;
    this.options = options;
    this.__isConnected = options?.isConnected ?? true;
    if (ENABLE_EXTRA_SECURITY_HOOKS) {
      this._textSanitizer = void 0;
    }
  }
  /**
   * The parent node into which the part renders its content.
   *
   * A ChildPart's content consists of a range of adjacent child nodes of
   * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and
   * `.endNode`).
   *
   * - If both `.startNode` and `.endNode` are non-null, then the part's content
   * consists of all siblings between `.startNode` and `.endNode`, exclusively.
   *
   * - If `.startNode` is non-null but `.endNode` is null, then the part's
   * content consists of all siblings following `.startNode`, up to and
   * including the last child of `.parentNode`. If `.endNode` is non-null, then
   * `.startNode` will always be non-null.
   *
   * - If both `.endNode` and `.startNode` are null, then the part's content
   * consists of all child nodes of `.parentNode`.
   */
  get parentNode() {
    let parentNode = wrap(this._$startNode).parentNode;
    const parent = this._$parent;
    if (parent !== void 0 && parentNode?.nodeType === 11) {
      parentNode = parent.parentNode;
    }
    return parentNode;
  }
  /**
   * The part's leading marker node, if any. See `.parentNode` for more
   * information.
   */
  get startNode() {
    return this._$startNode;
  }
  /**
   * The part's trailing marker node, if any. See `.parentNode` for more
   * information.
   */
  get endNode() {
    return this._$endNode;
  }
  _$setValue(value, directiveParent = this) {
    if (DEV_MODE && this.parentNode === null) {
      throw new Error(`This \`ChildPart\` has no \`parentNode\` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's \`innerHTML\` or \`textContent\` can do this.`);
    }
    value = resolveDirective(this, value, directiveParent);
    if (isPrimitive(value)) {
      if (value === nothing || value == null || value === "") {
        if (this._$committedValue !== nothing) {
          debugLogEvent && debugLogEvent({
            kind: "commit nothing to child",
            start: this._$startNode,
            end: this._$endNode,
            parent: this._$parent,
            options: this.options
          });
          this._$clear();
        }
        this._$committedValue = nothing;
      } else if (value !== this._$committedValue && value !== noChange) {
        this._commitText(value);
      }
    } else if (value["_$litType$"] !== void 0) {
      this._commitTemplateResult(value);
    } else if (value.nodeType !== void 0) {
      if (DEV_MODE && this.options?.host === value) {
        this._commitText(`[probable mistake: rendered a template's host in itself (commonly caused by writing \${this} in a template]`);
        console.warn(`Attempted to render the template host`, value, `inside itself. This is almost always a mistake, and in dev mode `, `we render some warning text. In production however, we'll `, `render it, which will usually result in an error, and sometimes `, `in the element disappearing from the DOM.`);
        return;
      }
      this._commitNode(value);
    } else if (isIterable(value)) {
      this._commitIterable(value);
    } else {
      this._commitText(value);
    }
  }
  _insert(node) {
    return wrap(wrap(this._$startNode).parentNode).insertBefore(node, this._$endNode);
  }
  _commitNode(value) {
    if (this._$committedValue !== value) {
      this._$clear();
      if (ENABLE_EXTRA_SECURITY_HOOKS && sanitizerFactoryInternal !== noopSanitizer) {
        const parentNodeName = this._$startNode.parentNode?.nodeName;
        if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
          let message = "Forbidden";
          if (DEV_MODE) {
            if (parentNodeName === "STYLE") {
              message = `Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css\`...\` literals to compose styles, and do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets.`;
            } else {
              message = `Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.`;
            }
          }
          throw new Error(message);
        }
      }
      debugLogEvent && debugLogEvent({
        kind: "commit node",
        start: this._$startNode,
        parent: this._$parent,
        value,
        options: this.options
      });
      this._$committedValue = this._insert(value);
    }
  }
  _commitText(value) {
    if (this._$committedValue !== nothing && isPrimitive(this._$committedValue)) {
      const node = wrap(this._$startNode).nextSibling;
      if (ENABLE_EXTRA_SECURITY_HOOKS) {
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer(node, "data", "property");
        }
        value = this._textSanitizer(value);
      }
      debugLogEvent && debugLogEvent({
        kind: "commit text",
        node,
        value,
        options: this.options
      });
      node.data = value;
    } else {
      if (ENABLE_EXTRA_SECURITY_HOOKS) {
        const textNode = d2.createTextNode("");
        this._commitNode(textNode);
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer(textNode, "data", "property");
        }
        value = this._textSanitizer(value);
        debugLogEvent && debugLogEvent({
          kind: "commit text",
          node: textNode,
          value,
          options: this.options
        });
        textNode.data = value;
      } else {
        this._commitNode(d2.createTextNode(value));
        debugLogEvent && debugLogEvent({
          kind: "commit text",
          node: wrap(this._$startNode).nextSibling,
          value,
          options: this.options
        });
      }
    }
    this._$committedValue = value;
  }
  _commitTemplateResult(result) {
    const { values, ["_$litType$"]: type } = result;
    const template = typeof type === "number" ? this._$getTemplate(result) : (type.el === void 0 && (type.el = Template.createElement(trustFromTemplateString(type.h, type.h[0]), this.options)), type);
    if (this._$committedValue?._$template === template) {
      debugLogEvent && debugLogEvent({
        kind: "template updating",
        template,
        instance: this._$committedValue,
        parts: this._$committedValue._$parts,
        options: this.options,
        values
      });
      this._$committedValue._update(values);
    } else {
      const instance = new TemplateInstance(template, this);
      const fragment = instance._clone(this.options);
      debugLogEvent && debugLogEvent({
        kind: "template instantiated",
        template,
        instance,
        parts: instance._$parts,
        options: this.options,
        fragment,
        values
      });
      instance._update(values);
      debugLogEvent && debugLogEvent({
        kind: "template instantiated and updated",
        template,
        instance,
        parts: instance._$parts,
        options: this.options,
        fragment,
        values
      });
      this._commitNode(fragment);
      this._$committedValue = instance;
    }
  }
  // Overridden via `litHtmlPolyfillSupport` to provide platform support.
  /** @internal */
  _$getTemplate(result) {
    let template = templateCache.get(result.strings);
    if (template === void 0) {
      templateCache.set(result.strings, template = new Template(result));
    }
    return template;
  }
  _commitIterable(value) {
    if (!isArray(this._$committedValue)) {
      this._$committedValue = [];
      this._$clear();
    }
    const itemParts = this._$committedValue;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      if (partIndex === itemParts.length) {
        itemParts.push(itemPart = new _ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options));
      } else {
        itemPart = itemParts[partIndex];
      }
      itemPart._$setValue(item);
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);
      itemParts.length = partIndex;
    }
  }
  /**
   * Removes the nodes contained within this Part from the DOM.
   *
   * @param start Start node to clear from, for clearing a subset of the part's
   *     DOM (used when truncating iterables)
   * @param from  When `start` is specified, the index within the iterable from
   *     which ChildParts are being removed, used for disconnecting directives
   *     in those Parts.
   *
   * @internal
   */
  _$clear(start = wrap(this._$startNode).nextSibling, from) {
    this._$notifyConnectionChanged?.(false, true, from);
    while (start !== this._$endNode) {
      const n2 = wrap(start).nextSibling;
      wrap(start).remove();
      start = n2;
    }
  }
  /**
   * Implementation of RootPart's `isConnected`. Note that this method
   * should only be called on `RootPart`s (the `ChildPart` returned from a
   * top-level `render()` call). It has no effect on non-root ChildParts.
   * @param isConnected Whether to set
   * @internal
   */
  setConnected(isConnected) {
    if (this._$parent === void 0) {
      this.__isConnected = isConnected;
      this._$notifyConnectionChanged?.(isConnected);
    } else if (DEV_MODE) {
      throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
    }
  }
};
var AttributePart = class {
  get tagName() {
    return this.element.tagName;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  constructor(element, name, strings, parent, options) {
    this.type = ATTRIBUTE_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this.element = element;
    this.name = name;
    this._$parent = parent;
    this.options = options;
    if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
      this._$committedValue = new Array(strings.length - 1).fill(new String());
      this.strings = strings;
    } else {
      this._$committedValue = nothing;
    }
    if (ENABLE_EXTRA_SECURITY_HOOKS) {
      this._sanitizer = void 0;
    }
  }
  /**
   * Sets the value of this part by resolving the value from possibly multiple
   * values and static strings and committing it to the DOM.
   * If this part is single-valued, `this._strings` will be undefined, and the
   * method will be called with a single value argument. If this part is
   * multi-value, `this._strings` will be defined, and the method is called
   * with the value array of the part's owning TemplateInstance, and an offset
   * into the value array from which the values should be read.
   * This method is overloaded this way to eliminate short-lived array slices
   * of the template instance values, and allow a fast-path for single-valued
   * parts.
   *
   * @param value The part value, or an array of values for multi-valued parts
   * @param valueIndex the index to start reading values from. `undefined` for
   *   single-valued parts
   * @param noCommit causes the part to not commit its value to the DOM. Used
   *   in hydration to prime attribute parts with their first-rendered value,
   *   but not set the attribute, and in SSR to no-op the DOM operation and
   *   capture the value for serialization.
   *
   * @internal
   */
  _$setValue(value, directiveParent = this, valueIndex, noCommit) {
    const strings = this.strings;
    let change = false;
    if (strings === void 0) {
      value = resolveDirective(this, value, directiveParent, 0);
      change = !isPrimitive(value) || value !== this._$committedValue && value !== noChange;
      if (change) {
        this._$committedValue = value;
      }
    } else {
      const values = value;
      value = strings[0];
      let i2, v;
      for (i2 = 0; i2 < strings.length - 1; i2++) {
        v = resolveDirective(this, values[valueIndex + i2], directiveParent, i2);
        if (v === noChange) {
          v = this._$committedValue[i2];
        }
        change ||= !isPrimitive(v) || v !== this._$committedValue[i2];
        if (v === nothing) {
          value = nothing;
        } else if (value !== nothing) {
          value += (v ?? "") + strings[i2 + 1];
        }
        this._$committedValue[i2] = v;
      }
    }
    if (change && !noCommit) {
      this._commitValue(value);
    }
  }
  /** @internal */
  _commitValue(value) {
    if (value === nothing) {
      wrap(this.element).removeAttribute(this.name);
    } else {
      if (ENABLE_EXTRA_SECURITY_HOOKS) {
        if (this._sanitizer === void 0) {
          this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "attribute");
        }
        value = this._sanitizer(value ?? "");
      }
      debugLogEvent && debugLogEvent({
        kind: "commit attribute",
        element: this.element,
        name: this.name,
        value,
        options: this.options
      });
      wrap(this.element).setAttribute(this.name, value ?? "");
    }
  }
};
var PropertyPart = class extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = PROPERTY_PART;
  }
  /** @internal */
  _commitValue(value) {
    if (ENABLE_EXTRA_SECURITY_HOOKS) {
      if (this._sanitizer === void 0) {
        this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "property");
      }
      value = this._sanitizer(value);
    }
    debugLogEvent && debugLogEvent({
      kind: "commit property",
      element: this.element,
      name: this.name,
      value,
      options: this.options
    });
    this.element[this.name] = value === nothing ? void 0 : value;
  }
};
var BooleanAttributePart = class extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = BOOLEAN_ATTRIBUTE_PART;
  }
  /** @internal */
  _commitValue(value) {
    debugLogEvent && debugLogEvent({
      kind: "commit boolean attribute",
      element: this.element,
      name: this.name,
      value: !!(value && value !== nothing),
      options: this.options
    });
    wrap(this.element).toggleAttribute(this.name, !!value && value !== nothing);
  }
};
var EventPart = class extends AttributePart {
  constructor(element, name, strings, parent, options) {
    super(element, name, strings, parent, options);
    this.type = EVENT_PART;
    if (DEV_MODE && this.strings !== void 0) {
      throw new Error(`A \`<${element.localName}>\` has a \`@${name}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`);
    }
  }
  // EventPart does not use the base _$setValue/_resolveValue implementation
  // since the dirty checking is more complex
  /** @internal */
  _$setValue(newListener, directiveParent = this) {
    newListener = resolveDirective(this, newListener, directiveParent, 0) ?? nothing;
    if (newListener === noChange) {
      return;
    }
    const oldListener = this._$committedValue;
    const shouldRemoveListener = newListener === nothing && oldListener !== nothing || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
    const shouldAddListener = newListener !== nothing && (oldListener === nothing || shouldRemoveListener);
    debugLogEvent && debugLogEvent({
      kind: "commit event listener",
      element: this.element,
      name: this.name,
      value: newListener,
      options: this.options,
      removeListener: shouldRemoveListener,
      addListener: shouldAddListener,
      oldListener
    });
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.name, this, oldListener);
    }
    if (shouldAddListener) {
      this.element.addEventListener(this.name, this, newListener);
    }
    this._$committedValue = newListener;
  }
  handleEvent(event) {
    if (typeof this._$committedValue === "function") {
      this._$committedValue.call(this.options?.host ?? this.element, event);
    } else {
      this._$committedValue.handleEvent(event);
    }
  }
};
var ElementPart = class {
  constructor(element, parent, options) {
    this.element = element;
    this.type = ELEMENT_PART;
    this._$disconnectableChildren = void 0;
    this._$parent = parent;
    this.options = options;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value) {
    debugLogEvent && debugLogEvent({
      kind: "commit to element binding",
      element: this.element,
      value,
      options: this.options
    });
    resolveDirective(this, value);
  }
};
var _$LH = {
  // Used in lit-ssr
  _boundAttributeSuffix: boundAttributeSuffix,
  _marker: marker,
  _markerMatch: markerMatch,
  _HTML_RESULT: HTML_RESULT,
  _getTemplateHtml: getTemplateHtml,
  // Used in tests and private-ssr-support
  _TemplateInstance: TemplateInstance,
  _isIterable: isIterable,
  _resolveDirective: resolveDirective,
  _ChildPart: ChildPart,
  _AttributePart: AttributePart,
  _BooleanAttributePart: BooleanAttributePart,
  _EventPart: EventPart,
  _PropertyPart: PropertyPart,
  _ElementPart: ElementPart
};
var polyfillSupport = DEV_MODE ? global2.litHtmlPolyfillSupportDevMode : global2.litHtmlPolyfillSupport;
polyfillSupport?.(Template, ChildPart);
(global2.litHtmlVersions ??= []).push("3.3.1");
if (DEV_MODE && global2.litHtmlVersions.length > 1) {
  queueMicrotask(() => {
    issueWarning("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
  });
}
var render = (value, container, options) => {
  if (DEV_MODE && container == null) {
    throw new TypeError(`The container to render into may not be ${container}`);
  }
  const renderId = DEV_MODE ? debugLogRenderId++ : 0;
  const partOwnerNode = options?.renderBefore ?? container;
  let part = partOwnerNode["_$litPart$"];
  debugLogEvent && debugLogEvent({
    kind: "begin render",
    id: renderId,
    value,
    container,
    options,
    part
  });
  if (part === void 0) {
    const endNode = options?.renderBefore ?? null;
    partOwnerNode["_$litPart$"] = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, void 0, options ?? {});
  }
  part._$setValue(value);
  debugLogEvent && debugLogEvent({
    kind: "end render",
    id: renderId,
    value,
    container,
    options,
    part
  });
  return part;
};
if (ENABLE_EXTRA_SECURITY_HOOKS) {
  render.setSanitizer = setSanitizer;
  render.createSanitizer = createSanitizer;
  if (DEV_MODE) {
    render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;
  }
}

// node_modules/@lit/reactive-element/development/css-tag.js
var NODE_MODE2 = false;
var global3 = globalThis;
var supportsAdoptingStyleSheets = global3.ShadowRoot && (global3.ShadyCSS === void 0 || global3.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var constructionToken = Symbol();
var cssTagCache = /* @__PURE__ */ new WeakMap();
var CSSResult = class {
  constructor(cssText, strings, safeToken) {
    this["_$cssResult$"] = true;
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
    this._strings = strings;
  }
  // This is a getter so that it's lazy. In practice, this means stylesheets
  // are not created until the first element instance is made.
  get styleSheet() {
    let styleSheet = this._styleSheet;
    const strings = this._strings;
    if (supportsAdoptingStyleSheets && styleSheet === void 0) {
      const cacheable = strings !== void 0 && strings.length === 1;
      if (cacheable) {
        styleSheet = cssTagCache.get(strings);
      }
      if (styleSheet === void 0) {
        (this._styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(this.cssText);
        if (cacheable) {
          cssTagCache.set(strings, styleSheet);
        }
      }
    }
    return styleSheet;
  }
  toString() {
    return this.cssText;
  }
};
var textFromCSSResult = (value) => {
  if (value["_$cssResult$"] === true) {
    return value.cssText;
  } else if (typeof value === "number") {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.`);
  }
};
var unsafeCSS = (value) => new CSSResult(typeof value === "string" ? value : String(value), void 0, constructionToken);
var css = (strings, ...values) => {
  const cssText = strings.length === 1 ? strings[0] : values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
  return new CSSResult(cssText, strings, constructionToken);
};
var adoptStyles = (renderRoot, styles2) => {
  if (supportsAdoptingStyleSheets) {
    renderRoot.adoptedStyleSheets = styles2.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
  } else {
    for (const s of styles2) {
      const style = document.createElement("style");
      const nonce = global3["litNonce"];
      if (nonce !== void 0) {
        style.setAttribute("nonce", nonce);
      }
      style.textContent = s.cssText;
      renderRoot.appendChild(style);
    }
  }
};
var cssResultFromStyleSheet = (sheet) => {
  let cssText = "";
  for (const rule of sheet.cssRules) {
    cssText += rule.cssText;
  }
  return unsafeCSS(cssText);
};
var getCompatibleStyle = supportsAdoptingStyleSheets || NODE_MODE2 && global3.CSSStyleSheet === void 0 ? (s) => s : (s) => s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;

// node_modules/@lit/reactive-element/development/reactive-element.js
var { is, defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, getPrototypeOf } = Object;
var NODE_MODE3 = false;
var global4 = globalThis;
if (NODE_MODE3) {
  global4.customElements ??= customElements;
}
var DEV_MODE2 = true;
var issueWarning2;
var trustedTypes2 = global4.trustedTypes;
var emptyStringForBooleanAttribute = trustedTypes2 ? trustedTypes2.emptyScript : "";
var polyfillSupport2 = DEV_MODE2 ? global4.reactiveElementPolyfillSupportDevMode : global4.reactiveElementPolyfillSupport;
if (DEV_MODE2) {
  global4.litIssuedWarnings ??= /* @__PURE__ */ new Set();
  issueWarning2 = (code, warning) => {
    warning += ` See https://lit.dev/msg/${code} for more information.`;
    if (!global4.litIssuedWarnings.has(warning) && !global4.litIssuedWarnings.has(code)) {
      console.warn(warning);
      global4.litIssuedWarnings.add(warning);
    }
  };
  queueMicrotask(() => {
    issueWarning2("dev-mode", `Lit is in dev mode. Not recommended for production!`);
    if (global4.ShadyDOM?.inUse && polyfillSupport2 === void 0) {
      issueWarning2("polyfill-support-missing", `Shadow DOM is being polyfilled via \`ShadyDOM\` but the \`polyfill-support\` module has not been loaded.`);
    }
  });
}
var debugLogEvent2 = DEV_MODE2 ? (event) => {
  const shouldEmit = global4.emitLitDebugLogEvents;
  if (!shouldEmit) {
    return;
  }
  global4.dispatchEvent(new CustomEvent("lit-debug", {
    detail: event
  }));
} : void 0;
var JSCompiler_renameProperty = (prop, _obj) => prop;
var defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        value = value ? emptyStringForBooleanAttribute : null;
        break;
      case Object:
      case Array:
        value = value == null ? value : JSON.stringify(value);
        break;
    }
    return value;
  },
  fromAttribute(value, type) {
    let fromValue = value;
    switch (type) {
      case Boolean:
        fromValue = value !== null;
        break;
      case Number:
        fromValue = value === null ? null : Number(value);
        break;
      case Object:
      case Array:
        try {
          fromValue = JSON.parse(value);
        } catch (e) {
          fromValue = null;
        }
        break;
    }
    return fromValue;
  }
};
var notEqual = (value, old) => !is(value, old);
var defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  useDefault: false,
  hasChanged: notEqual
};
Symbol.metadata ??= Symbol("metadata");
global4.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var ReactiveElement = class extends HTMLElement {
  /**
   * Adds an initializer function to the class that is called during instance
   * construction.
   *
   * This is useful for code that runs against a `ReactiveElement`
   * subclass, such as a decorator, that needs to do work for each
   * instance, such as setting up a `ReactiveController`.
   *
   * ```ts
   * const myDecorator = (target: typeof ReactiveElement, key: string) => {
   *   target.addInitializer((instance: ReactiveElement) => {
   *     // This is run during construction of the element
   *     new MyController(instance);
   *   });
   * }
   * ```
   *
   * Decorating a field will then cause each instance to run an initializer
   * that adds a controller:
   *
   * ```ts
   * class MyElement extends LitElement {
   *   @myDecorator foo;
   * }
   * ```
   *
   * Initializers are stored per-constructor. Adding an initializer to a
   * subclass does not add it to a superclass. Since initializers are run in
   * constructors, initializers will run in order of the class hierarchy,
   * starting with superclasses and progressing to the instance's class.
   *
   * @nocollapse
   */
  static addInitializer(initializer) {
    this.__prepare();
    (this._initializers ??= []).push(initializer);
  }
  /**
   * Returns a list of attributes corresponding to the registered properties.
   * @nocollapse
   * @category attributes
   */
  static get observedAttributes() {
    this.finalize();
    return this.__attributeToPropertyMap && [...this.__attributeToPropertyMap.keys()];
  }
  /**
   * Creates a property accessor on the element prototype if one does not exist
   * and stores a {@linkcode PropertyDeclaration} for the property with the
   * given options. The property setter calls the property's `hasChanged`
   * property option or uses a strict identity check to determine whether or not
   * to request an update.
   *
   * This method may be overridden to customize properties; however,
   * when doing so, it's important to call `super.createProperty` to ensure
   * the property is setup correctly. This method calls
   * `getPropertyDescriptor` internally to get a descriptor to install.
   * To customize what properties do when they are get or set, override
   * `getPropertyDescriptor`. To customize the options for a property,
   * implement `createProperty` like this:
   *
   * ```ts
   * static createProperty(name, options) {
   *   options = Object.assign(options, {myOption: true});
   *   super.createProperty(name, options);
   * }
   * ```
   *
   * @nocollapse
   * @category properties
   */
  static createProperty(name, options = defaultPropertyDeclaration) {
    if (options.state) {
      options.attribute = false;
    }
    this.__prepare();
    if (this.prototype.hasOwnProperty(name)) {
      options = Object.create(options);
      options.wrapped = true;
    }
    this.elementProperties.set(name, options);
    if (!options.noAccessor) {
      const key = DEV_MODE2 ? (
        // Use Symbol.for in dev mode to make it easier to maintain state
        // when doing HMR.
        Symbol.for(`${String(name)} (@property() cache)`)
      ) : Symbol();
      const descriptor = this.getPropertyDescriptor(name, key, options);
      if (descriptor !== void 0) {
        defineProperty(this.prototype, name, descriptor);
      }
    }
  }
  /**
   * Returns a property descriptor to be defined on the given named property.
   * If no descriptor is returned, the property will not become an accessor.
   * For example,
   *
   * ```ts
   * class MyElement extends LitElement {
   *   static getPropertyDescriptor(name, key, options) {
   *     const defaultDescriptor =
   *         super.getPropertyDescriptor(name, key, options);
   *     const setter = defaultDescriptor.set;
   *     return {
   *       get: defaultDescriptor.get,
   *       set(value) {
   *         setter.call(this, value);
   *         // custom action.
   *       },
   *       configurable: true,
   *       enumerable: true
   *     }
   *   }
   * }
   * ```
   *
   * @nocollapse
   * @category properties
   */
  static getPropertyDescriptor(name, key, options) {
    const { get, set } = getOwnPropertyDescriptor(this.prototype, name) ?? {
      get() {
        return this[key];
      },
      set(v) {
        this[key] = v;
      }
    };
    if (DEV_MODE2 && get == null) {
      if ("value" in (getOwnPropertyDescriptor(this.prototype, name) ?? {})) {
        throw new Error(`Field ${JSON.stringify(String(name))} on ${this.name} was declared as a reactive property but it's actually declared as a value on the prototype. Usually this is due to using @property or @state on a method.`);
      }
      issueWarning2("reactive-property-without-getter", `Field ${JSON.stringify(String(name))} on ${this.name} was declared as a reactive property but it does not have a getter. This will be an error in a future version of Lit.`);
    }
    return {
      get,
      set(value) {
        const oldValue = get?.call(this);
        set?.call(this, value);
        this.requestUpdate(name, oldValue, options);
      },
      configurable: true,
      enumerable: true
    };
  }
  /**
   * Returns the property options associated with the given property.
   * These options are defined with a `PropertyDeclaration` via the `properties`
   * object or the `@property` decorator and are registered in
   * `createProperty(...)`.
   *
   * Note, this method should be considered "final" and not overridden. To
   * customize the options for a given property, override
   * {@linkcode createProperty}.
   *
   * @nocollapse
   * @final
   * @category properties
   */
  static getPropertyOptions(name) {
    return this.elementProperties.get(name) ?? defaultPropertyDeclaration;
  }
  /**
   * Initializes static own properties of the class used in bookkeeping
   * for element properties, initializers, etc.
   *
   * Can be called multiple times by code that needs to ensure these
   * properties exist before using them.
   *
   * This method ensures the superclass is finalized so that inherited
   * property metadata can be copied down.
   * @nocollapse
   */
  static __prepare() {
    if (this.hasOwnProperty(JSCompiler_renameProperty("elementProperties", this))) {
      return;
    }
    const superCtor = getPrototypeOf(this);
    superCtor.finalize();
    if (superCtor._initializers !== void 0) {
      this._initializers = [...superCtor._initializers];
    }
    this.elementProperties = new Map(superCtor.elementProperties);
  }
  /**
   * Finishes setting up the class so that it's ready to be registered
   * as a custom element and instantiated.
   *
   * This method is called by the ReactiveElement.observedAttributes getter.
   * If you override the observedAttributes getter, you must either call
   * super.observedAttributes to trigger finalization, or call finalize()
   * yourself.
   *
   * @nocollapse
   */
  static finalize() {
    if (this.hasOwnProperty(JSCompiler_renameProperty("finalized", this))) {
      return;
    }
    this.finalized = true;
    this.__prepare();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
      const props = this.properties;
      const propKeys = [
        ...getOwnPropertyNames(props),
        ...getOwnPropertySymbols(props)
      ];
      for (const p of propKeys) {
        this.createProperty(p, props[p]);
      }
    }
    const metadata = this[Symbol.metadata];
    if (metadata !== null) {
      const properties = litPropertyMetadata.get(metadata);
      if (properties !== void 0) {
        for (const [p, options] of properties) {
          this.elementProperties.set(p, options);
        }
      }
    }
    this.__attributeToPropertyMap = /* @__PURE__ */ new Map();
    for (const [p, options] of this.elementProperties) {
      const attr = this.__attributeNameForProperty(p, options);
      if (attr !== void 0) {
        this.__attributeToPropertyMap.set(attr, p);
      }
    }
    this.elementStyles = this.finalizeStyles(this.styles);
    if (DEV_MODE2) {
      if (this.hasOwnProperty("createProperty")) {
        issueWarning2("no-override-create-property", "Overriding ReactiveElement.createProperty() is deprecated. The override will not be called with standard decorators");
      }
      if (this.hasOwnProperty("getPropertyDescriptor")) {
        issueWarning2("no-override-get-property-descriptor", "Overriding ReactiveElement.getPropertyDescriptor() is deprecated. The override will not be called with standard decorators");
      }
    }
  }
  /**
   * Takes the styles the user supplied via the `static styles` property and
   * returns the array of styles to apply to the element.
   * Override this method to integrate into a style management system.
   *
   * Styles are deduplicated preserving the _last_ instance in the list. This
   * is a performance optimization to avoid duplicated styles that can occur
   * especially when composing via subclassing. The last item is kept to try
   * to preserve the cascade order with the assumption that it's most important
   * that last added styles override previous styles.
   *
   * @nocollapse
   * @category styles
   */
  static finalizeStyles(styles2) {
    const elementStyles2 = [];
    if (Array.isArray(styles2)) {
      const set = new Set(styles2.flat(Infinity).reverse());
      for (const s of set) {
        elementStyles2.unshift(getCompatibleStyle(s));
      }
    } else if (styles2 !== void 0) {
      elementStyles2.push(getCompatibleStyle(styles2));
    }
    return elementStyles2;
  }
  /**
   * Returns the property name for the given attribute `name`.
   * @nocollapse
   */
  static __attributeNameForProperty(name, options) {
    const attribute = options.attribute;
    return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name === "string" ? name.toLowerCase() : void 0;
  }
  constructor() {
    super();
    this.__instanceProperties = void 0;
    this.isUpdatePending = false;
    this.hasUpdated = false;
    this.__reflectingProperty = null;
    this.__initialize();
  }
  /**
   * Internal only override point for customizing work done when elements
   * are constructed.
   */
  __initialize() {
    this.__updatePromise = new Promise((res) => this.enableUpdating = res);
    this._$changedProperties = /* @__PURE__ */ new Map();
    this.__saveInstanceProperties();
    this.requestUpdate();
    this.constructor._initializers?.forEach((i2) => i2(this));
  }
  /**
   * Registers a `ReactiveController` to participate in the element's reactive
   * update cycle. The element automatically calls into any registered
   * controllers during its lifecycle callbacks.
   *
   * If the element is connected when `addController()` is called, the
   * controller's `hostConnected()` callback will be immediately called.
   * @category controllers
   */
  addController(controller6) {
    (this.__controllers ??= /* @__PURE__ */ new Set()).add(controller6);
    if (this.renderRoot !== void 0 && this.isConnected) {
      controller6.hostConnected?.();
    }
  }
  /**
   * Removes a `ReactiveController` from the element.
   * @category controllers
   */
  removeController(controller6) {
    this.__controllers?.delete(controller6);
  }
  /**
   * Fixes any properties set on the instance before upgrade time.
   * Otherwise these would shadow the accessor and break these properties.
   * The properties are stored in a Map which is played back after the
   * constructor runs.
   */
  __saveInstanceProperties() {
    const instanceProperties = /* @__PURE__ */ new Map();
    const elementProperties = this.constructor.elementProperties;
    for (const p of elementProperties.keys()) {
      if (this.hasOwnProperty(p)) {
        instanceProperties.set(p, this[p]);
        delete this[p];
      }
    }
    if (instanceProperties.size > 0) {
      this.__instanceProperties = instanceProperties;
    }
  }
  /**
   * Returns the node into which the element should render and by default
   * creates and returns an open shadowRoot. Implement to customize where the
   * element's DOM is rendered. For example, to render into the element's
   * childNodes, return `this`.
   *
   * @return Returns a node into which to render.
   * @category rendering
   */
  createRenderRoot() {
    const renderRoot = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    adoptStyles(renderRoot, this.constructor.elementStyles);
    return renderRoot;
  }
  /**
   * On first connection, creates the element's renderRoot, sets up
   * element styling, and enables updating.
   * @category lifecycle
   */
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot();
    this.enableUpdating(true);
    this.__controllers?.forEach((c) => c.hostConnected?.());
  }
  /**
   * Note, this method should be considered final and not overridden. It is
   * overridden on the element instance with a function that triggers the first
   * update.
   * @category updates
   */
  enableUpdating(_requestedUpdate) {
  }
  /**
   * Allows for `super.disconnectedCallback()` in extensions while
   * reserving the possibility of making non-breaking feature additions
   * when disconnecting at some point in the future.
   * @category lifecycle
   */
  disconnectedCallback() {
    this.__controllers?.forEach((c) => c.hostDisconnected?.());
  }
  /**
   * Synchronizes property values when attributes change.
   *
   * Specifically, when an attribute is set, the corresponding property is set.
   * You should rarely need to implement this callback. If this method is
   * overridden, `super.attributeChangedCallback(name, _old, value)` must be
   * called.
   *
   * See [responding to attribute changes](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements#responding_to_attribute_changes)
   * on MDN for more information about the `attributeChangedCallback`.
   * @category attributes
   */
  attributeChangedCallback(name, _old, value) {
    this._$attributeToProperty(name, value);
  }
  __propertyToAttribute(name, value) {
    const elemProperties = this.constructor.elementProperties;
    const options = elemProperties.get(name);
    const attr = this.constructor.__attributeNameForProperty(name, options);
    if (attr !== void 0 && options.reflect === true) {
      const converter = options.converter?.toAttribute !== void 0 ? options.converter : defaultConverter;
      const attrValue = converter.toAttribute(value, options.type);
      if (DEV_MODE2 && this.constructor.enabledWarnings.includes("migration") && attrValue === void 0) {
        issueWarning2("undefined-attribute-value", `The attribute value for the ${name} property is undefined on element ${this.localName}. The attribute will be removed, but in the previous version of \`ReactiveElement\`, the attribute would not have changed.`);
      }
      this.__reflectingProperty = name;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this.__reflectingProperty = null;
    }
  }
  /** @internal */
  _$attributeToProperty(name, value) {
    const ctor = this.constructor;
    const propName = ctor.__attributeToPropertyMap.get(name);
    if (propName !== void 0 && this.__reflectingProperty !== propName) {
      const options = ctor.getPropertyOptions(propName);
      const converter = typeof options.converter === "function" ? { fromAttribute: options.converter } : options.converter?.fromAttribute !== void 0 ? options.converter : defaultConverter;
      this.__reflectingProperty = propName;
      const convertedValue = converter.fromAttribute(value, options.type);
      this[propName] = convertedValue ?? this.__defaultValues?.get(propName) ?? // eslint-disable-next-line @typescript-eslint/no-explicit-any
      convertedValue;
      this.__reflectingProperty = null;
    }
  }
  /**
   * Requests an update which is processed asynchronously. This should be called
   * when an element should update based on some state not triggered by setting
   * a reactive property. In this case, pass no arguments. It should also be
   * called when manually implementing a property setter. In this case, pass the
   * property `name` and `oldValue` to ensure that any configured property
   * options are honored.
   *
   * @param name name of requesting property
   * @param oldValue old value of requesting property
   * @param options property options to use instead of the previously
   *     configured options
   * @category updates
   */
  requestUpdate(name, oldValue, options) {
    if (name !== void 0) {
      if (DEV_MODE2 && name instanceof Event) {
        issueWarning2(``, `The requestUpdate() method was called with an Event as the property name. This is probably a mistake caused by binding this.requestUpdate as an event listener. Instead bind a function that will call it with no arguments: () => this.requestUpdate()`);
      }
      const ctor = this.constructor;
      const newValue = this[name];
      options ??= ctor.getPropertyOptions(name);
      const changed = (options.hasChanged ?? notEqual)(newValue, oldValue) || // When there is no change, check a corner case that can occur when
      // 1. there's a initial value which was not reflected
      // 2. the property is subsequently set to this value.
      // For example, `prop: {useDefault: true, reflect: true}`
      // and el.prop = 'foo'. This should be considered a change if the
      // attribute is not set because we will now reflect the property to the attribute.
      options.useDefault && options.reflect && newValue === this.__defaultValues?.get(name) && !this.hasAttribute(ctor.__attributeNameForProperty(name, options));
      if (changed) {
        this._$changeProperty(name, oldValue, options);
      } else {
        return;
      }
    }
    if (this.isUpdatePending === false) {
      this.__updatePromise = this.__enqueueUpdate();
    }
  }
  /**
   * @internal
   */
  _$changeProperty(name, oldValue, { useDefault, reflect, wrapped }, initializeValue) {
    if (useDefault && !(this.__defaultValues ??= /* @__PURE__ */ new Map()).has(name)) {
      this.__defaultValues.set(name, initializeValue ?? oldValue ?? this[name]);
      if (wrapped !== true || initializeValue !== void 0) {
        return;
      }
    }
    if (!this._$changedProperties.has(name)) {
      if (!this.hasUpdated && !useDefault) {
        oldValue = void 0;
      }
      this._$changedProperties.set(name, oldValue);
    }
    if (reflect === true && this.__reflectingProperty !== name) {
      (this.__reflectingProperties ??= /* @__PURE__ */ new Set()).add(name);
    }
  }
  /**
   * Sets up the element to asynchronously update.
   */
  async __enqueueUpdate() {
    this.isUpdatePending = true;
    try {
      await this.__updatePromise;
    } catch (e) {
      Promise.reject(e);
    }
    const result = this.scheduleUpdate();
    if (result != null) {
      await result;
    }
    return !this.isUpdatePending;
  }
  /**
   * Schedules an element update. You can override this method to change the
   * timing of updates by returning a Promise. The update will await the
   * returned Promise, and you should resolve the Promise to allow the update
   * to proceed. If this method is overridden, `super.scheduleUpdate()`
   * must be called.
   *
   * For instance, to schedule updates to occur just before the next frame:
   *
   * ```ts
   * override protected async scheduleUpdate(): Promise<unknown> {
   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
   *   super.scheduleUpdate();
   * }
   * ```
   * @category updates
   */
  scheduleUpdate() {
    const result = this.performUpdate();
    if (DEV_MODE2 && this.constructor.enabledWarnings.includes("async-perform-update") && typeof result?.then === "function") {
      issueWarning2("async-perform-update", `Element ${this.localName} returned a Promise from performUpdate(). This behavior is deprecated and will be removed in a future version of ReactiveElement.`);
    }
    return result;
  }
  /**
   * Performs an element update. Note, if an exception is thrown during the
   * update, `firstUpdated` and `updated` will not be called.
   *
   * Call `performUpdate()` to immediately process a pending update. This should
   * generally not be needed, but it can be done in rare cases when you need to
   * update synchronously.
   *
   * @category updates
   */
  performUpdate() {
    if (!this.isUpdatePending) {
      return;
    }
    debugLogEvent2?.({ kind: "update" });
    if (!this.hasUpdated) {
      this.renderRoot ??= this.createRenderRoot();
      if (DEV_MODE2) {
        const ctor = this.constructor;
        const shadowedProperties = [...ctor.elementProperties.keys()].filter((p) => this.hasOwnProperty(p) && p in getPrototypeOf(this));
        if (shadowedProperties.length) {
          throw new Error(`The following properties on element ${this.localName} will not trigger updates as expected because they are set using class fields: ${shadowedProperties.join(", ")}. Native class fields and some compiled output will overwrite accessors used for detecting changes. See https://lit.dev/msg/class-field-shadowing for more information.`);
        }
      }
      if (this.__instanceProperties) {
        for (const [p, value] of this.__instanceProperties) {
          this[p] = value;
        }
        this.__instanceProperties = void 0;
      }
      const elementProperties = this.constructor.elementProperties;
      if (elementProperties.size > 0) {
        for (const [p, options] of elementProperties) {
          const { wrapped } = options;
          const value = this[p];
          if (wrapped === true && !this._$changedProperties.has(p) && value !== void 0) {
            this._$changeProperty(p, void 0, options, value);
          }
        }
      }
    }
    let shouldUpdate = false;
    const changedProperties = this._$changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.willUpdate(changedProperties);
        this.__controllers?.forEach((c) => c.hostUpdate?.());
        this.update(changedProperties);
      } else {
        this.__markUpdated();
      }
    } catch (e) {
      shouldUpdate = false;
      this.__markUpdated();
      throw e;
    }
    if (shouldUpdate) {
      this._$didUpdate(changedProperties);
    }
  }
  /**
   * Invoked before `update()` to compute values needed during the update.
   *
   * Implement `willUpdate` to compute property values that depend on other
   * properties and are used in the rest of the update process.
   *
   * ```ts
   * willUpdate(changedProperties) {
   *   // only need to check changed properties for an expensive computation.
   *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {
   *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);
   *   }
   * }
   *
   * render() {
   *   return html`SHA: ${this.sha}`;
   * }
   * ```
   *
   * @category updates
   */
  willUpdate(_changedProperties) {
  }
  // Note, this is an override point for polyfill-support.
  // @internal
  _$didUpdate(changedProperties) {
    this.__controllers?.forEach((c) => c.hostUpdated?.());
    if (!this.hasUpdated) {
      this.hasUpdated = true;
      this.firstUpdated(changedProperties);
    }
    this.updated(changedProperties);
    if (DEV_MODE2 && this.isUpdatePending && this.constructor.enabledWarnings.includes("change-in-update")) {
      issueWarning2("change-in-update", `Element ${this.localName} scheduled an update (generally because a property was set) after an update completed, causing a new update to be scheduled. This is inefficient and should be avoided unless the next update can only be scheduled as a side effect of the previous update.`);
    }
  }
  __markUpdated() {
    this._$changedProperties = /* @__PURE__ */ new Map();
    this.isUpdatePending = false;
  }
  /**
   * Returns a Promise that resolves when the element has completed updating.
   * The Promise value is a boolean that is `true` if the element completed the
   * update without triggering another update. The Promise result is `false` if
   * a property was set inside `updated()`. If the Promise is rejected, an
   * exception was thrown during the update.
   *
   * To await additional asynchronous work, override the `getUpdateComplete`
   * method. For example, it is sometimes useful to await a rendered element
   * before fulfilling this Promise. To do this, first await
   * `super.getUpdateComplete()`, then any subsequent state.
   *
   * @return A promise of a boolean that resolves to true if the update completed
   *     without triggering another update.
   * @category updates
   */
  get updateComplete() {
    return this.getUpdateComplete();
  }
  /**
   * Override point for the `updateComplete` promise.
   *
   * It is not safe to override the `updateComplete` getter directly due to a
   * limitation in TypeScript which means it is not possible to call a
   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
   * This method should be overridden instead. For example:
   *
   * ```ts
   * class MyElement extends LitElement {
   *   override async getUpdateComplete() {
   *     const result = await super.getUpdateComplete();
   *     await this._myChild.updateComplete;
   *     return result;
   *   }
   * }
   * ```
   *
   * @return A promise of a boolean that resolves to true if the update completed
   *     without triggering another update.
   * @category updates
   */
  getUpdateComplete() {
    return this.__updatePromise;
  }
  /**
   * Controls whether or not `update()` should be called when the element requests
   * an update. By default, this method always returns `true`, but this can be
   * customized to control when to update.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  shouldUpdate(_changedProperties) {
    return true;
  }
  /**
   * Updates the element. This method reflects property values to attributes.
   * It can be overridden to render and keep updated element DOM.
   * Setting properties inside this method will *not* trigger
   * another update.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  update(_changedProperties) {
    this.__reflectingProperties &&= this.__reflectingProperties.forEach((p) => this.__propertyToAttribute(p, this[p]));
    this.__markUpdated();
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  updated(_changedProperties) {
  }
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * ```ts
   * firstUpdated() {
   *   this.renderRoot.getElementById('my-text-area').focus();
   * }
   * ```
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  firstUpdated(_changedProperties) {
  }
};
ReactiveElement.elementStyles = [];
ReactiveElement.shadowRootOptions = { mode: "open" };
ReactiveElement[JSCompiler_renameProperty("elementProperties", ReactiveElement)] = /* @__PURE__ */ new Map();
ReactiveElement[JSCompiler_renameProperty("finalized", ReactiveElement)] = /* @__PURE__ */ new Map();
polyfillSupport2?.({ ReactiveElement });
if (DEV_MODE2) {
  ReactiveElement.enabledWarnings = [
    "change-in-update",
    "async-perform-update"
  ];
  const ensureOwnWarnings = function(ctor) {
    if (!ctor.hasOwnProperty(JSCompiler_renameProperty("enabledWarnings", ctor))) {
      ctor.enabledWarnings = ctor.enabledWarnings.slice();
    }
  };
  ReactiveElement.enableWarning = function(warning) {
    ensureOwnWarnings(this);
    if (!this.enabledWarnings.includes(warning)) {
      this.enabledWarnings.push(warning);
    }
  };
  ReactiveElement.disableWarning = function(warning) {
    ensureOwnWarnings(this);
    const i2 = this.enabledWarnings.indexOf(warning);
    if (i2 >= 0) {
      this.enabledWarnings.splice(i2, 1);
    }
  };
}
(global4.reactiveElementVersions ??= []).push("2.1.1");
if (DEV_MODE2 && global4.reactiveElementVersions.length > 1) {
  queueMicrotask(() => {
    issueWarning2("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
  });
}

// node_modules/lit-element/development/lit-element.js
var JSCompiler_renameProperty2 = (prop, _obj) => prop;
var DEV_MODE3 = true;
var global5 = globalThis;
var issueWarning3;
if (DEV_MODE3) {
  global5.litIssuedWarnings ??= /* @__PURE__ */ new Set();
  issueWarning3 = (code, warning) => {
    warning += ` See https://lit.dev/msg/${code} for more information.`;
    if (!global5.litIssuedWarnings.has(warning) && !global5.litIssuedWarnings.has(code)) {
      console.warn(warning);
      global5.litIssuedWarnings.add(warning);
    }
  };
}
var LitElement = class extends ReactiveElement {
  constructor() {
    super(...arguments);
    this.renderOptions = { host: this };
    this.__childPart = void 0;
  }
  /**
   * @category rendering
   */
  createRenderRoot() {
    const renderRoot = super.createRenderRoot();
    this.renderOptions.renderBefore ??= renderRoot.firstChild;
    return renderRoot;
  }
  /**
   * Updates the element. This method reflects property values to attributes
   * and calls `render` to render DOM via lit-html. Setting properties inside
   * this method will *not* trigger another update.
   * @param changedProperties Map of changed properties with old values
   * @category updates
   */
  update(changedProperties) {
    const value = this.render();
    if (!this.hasUpdated) {
      this.renderOptions.isConnected = this.isConnected;
    }
    super.update(changedProperties);
    this.__childPart = render(value, this.renderRoot, this.renderOptions);
  }
  /**
   * Invoked when the component is added to the document's DOM.
   *
   * In `connectedCallback()` you should setup tasks that should only occur when
   * the element is connected to the document. The most common of these is
   * adding event listeners to nodes external to the element, like a keydown
   * event handler added to the window.
   *
   * ```ts
   * connectedCallback() {
   *   super.connectedCallback();
   *   addEventListener('keydown', this._handleKeydown);
   * }
   * ```
   *
   * Typically, anything done in `connectedCallback()` should be undone when the
   * element is disconnected, in `disconnectedCallback()`.
   *
   * @category lifecycle
   */
  connectedCallback() {
    super.connectedCallback();
    this.__childPart?.setConnected(true);
  }
  /**
   * Invoked when the component is removed from the document's DOM.
   *
   * This callback is the main signal to the element that it may no longer be
   * used. `disconnectedCallback()` should ensure that nothing is holding a
   * reference to the element (such as event listeners added to nodes external
   * to the element), so that it is free to be garbage collected.
   *
   * ```ts
   * disconnectedCallback() {
   *   super.disconnectedCallback();
   *   window.removeEventListener('keydown', this._handleKeydown);
   * }
   * ```
   *
   * An element may be re-connected after being disconnected.
   *
   * @category lifecycle
   */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__childPart?.setConnected(false);
  }
  /**
   * Invoked on each update to perform rendering tasks. This method may return
   * any value renderable by lit-html's `ChildPart` - typically a
   * `TemplateResult`. Setting properties inside this method will *not* trigger
   * the element to update.
   * @category rendering
   */
  render() {
    return noChange;
  }
};
LitElement["_$litElement$"] = true;
LitElement[JSCompiler_renameProperty2("finalized", LitElement)] = true;
global5.litElementHydrateSupport?.({ LitElement });
var polyfillSupport3 = DEV_MODE3 ? global5.litElementPolyfillSupportDevMode : global5.litElementPolyfillSupport;
polyfillSupport3?.({ LitElement });
(global5.litElementVersions ??= []).push("4.2.1");
if (DEV_MODE3 && global5.litElementVersions.length > 1) {
  queueMicrotask(() => {
    issueWarning3("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
  });
}

// node_modules/@reown/appkit-ui/dist/esm/src/utils/ThemeConstantsUtil.js
var colors = {
  black: "#202020",
  white: "#FFFFFF",
  white010: "rgba(255, 255, 255, 0.1)",
  accent010: "rgba(9, 136, 240, 0.1)",
  accent020: "rgba(9, 136, 240, 0.2)",
  accent030: "rgba(9, 136, 240, 0.3)",
  accent040: "rgba(9, 136, 240, 0.4)",
  accent050: "rgba(9, 136, 240, 0.5)",
  accent060: "rgba(9, 136, 240, 0.6)",
  accent070: "rgba(9, 136, 240, 0.7)",
  accent080: "rgba(9, 136, 240, 0.8)",
  accent090: "rgba(9, 136, 240, 0.9)",
  accent100: "rgba(9, 136, 240, 1.0)",
  accentSecondary010: "rgba(199, 185, 148, 0.1)",
  accentSecondary020: "rgba(199, 185, 148, 0.2)",
  accentSecondary030: "rgba(199, 185, 148, 0.3)",
  accentSecondary040: "rgba(199, 185, 148, 0.4)",
  accentSecondary050: "rgba(199, 185, 148, 0.5)",
  accentSecondary060: "rgba(199, 185, 148, 0.6)",
  accentSecondary070: "rgba(199, 185, 148, 0.7)",
  accentSecondary080: "rgba(199, 185, 148, 0.8)",
  accentSecondary090: "rgba(199, 185, 148, 0.9)",
  accentSecondary100: "rgba(199, 185, 148, 1.0)",
  productWalletKit: "#FFB800",
  productAppKit: "#FF573B",
  productCloud: "#0988F0",
  productDocumentation: "#008847",
  neutrals050: "#F6F6F6",
  neutrals100: "#F3F3F3",
  neutrals200: "#E9E9E9",
  neutrals300: "#D0D0D0",
  neutrals400: "#BBB",
  neutrals500: "#9A9A9A",
  neutrals600: "#6C6C6C",
  neutrals700: "#4F4F4F",
  neutrals800: "#363636",
  neutrals900: "#2A2A2A",
  neutrals1000: "#252525",
  semanticSuccess010: "rgba(48, 164, 107, 0.1)",
  semanticSuccess020: "rgba(48, 164, 107, 0.2)",
  semanticSuccess030: "rgba(48, 164, 107, 0.3)",
  semanticSuccess040: "rgba(48, 164, 107, 0.4)",
  semanticSuccess050: "rgba(48, 164, 107, 0.5)",
  semanticSuccess060: "rgba(48, 164, 107, 0.6)",
  semanticSuccess070: "rgba(48, 164, 107, 0.7)",
  semanticSuccess080: "rgba(48, 164, 107, 0.8)",
  semanticSuccess090: "rgba(48, 164, 107, 0.9)",
  semanticSuccess100: "rgba(48, 164, 107, 1.0)",
  semanticError010: "rgba(223, 74, 52, 0.1)",
  semanticError020: "rgba(223, 74, 52, 0.2)",
  semanticError030: "rgba(223, 74, 52, 0.3)",
  semanticError040: "rgba(223, 74, 52, 0.4)",
  semanticError050: "rgba(223, 74, 52, 0.5)",
  semanticError060: "rgba(223, 74, 52, 0.6)",
  semanticError070: "rgba(223, 74, 52, 0.7)",
  semanticError080: "rgba(223, 74, 52, 0.8)",
  semanticError090: "rgba(223, 74, 52, 0.9)",
  semanticError100: "rgba(223, 74, 52, 1.0)",
  semanticWarning010: "rgba(243, 161, 63, 0.1)",
  semanticWarning020: "rgba(243, 161, 63, 0.2)",
  semanticWarning030: "rgba(243, 161, 63, 0.3)",
  semanticWarning040: "rgba(243, 161, 63, 0.4)",
  semanticWarning050: "rgba(243, 161, 63, 0.5)",
  semanticWarning060: "rgba(243, 161, 63, 0.6)",
  semanticWarning070: "rgba(243, 161, 63, 0.7)",
  semanticWarning080: "rgba(243, 161, 63, 0.8)",
  semanticWarning090: "rgba(243, 161, 63, 0.9)",
  semanticWarning100: "rgba(243, 161, 63, 1.0)"
};
var tokens = {
  core: {
    backgroundAccentPrimary: "#0988F0",
    backgroundAccentCertified: "#C7B994",
    backgroundWalletKit: "#FFB800",
    backgroundAppKit: "#FF573B",
    backgroundCloud: "#0988F0",
    backgroundDocumentation: "#008847",
    backgroundSuccess: "rgba(48, 164, 107, 0.20)",
    backgroundError: "rgba(223, 74, 52, 0.20)",
    backgroundWarning: "rgba(243, 161, 63, 0.20)",
    textAccentPrimary: "#0988F0",
    textAccentCertified: "#C7B994",
    textWalletKit: "#FFB800",
    textAppKit: "#FF573B",
    textCloud: "#0988F0",
    textDocumentation: "#008847",
    textSuccess: "#30A46B",
    textError: "#DF4A34",
    textWarning: "#F3A13F",
    borderAccentPrimary: "#0988F0",
    borderSecondary: "#C7B994",
    borderSuccess: "#30A46B",
    borderError: "#DF4A34",
    borderWarning: "#F3A13F",
    foregroundAccent010: "rgba(9, 136, 240, 0.1)",
    foregroundAccent020: "rgba(9, 136, 240, 0.2)",
    foregroundAccent040: "rgba(9, 136, 240, 0.4)",
    foregroundAccent060: "rgba(9, 136, 240, 0.6)",
    foregroundSecondary020: "rgba(199, 185, 148, 0.2)",
    foregroundSecondary040: "rgba(199, 185, 148, 0.4)",
    foregroundSecondary060: "rgba(199, 185, 148, 0.6)",
    iconAccentPrimary: "#0988F0",
    iconAccentCertified: "#C7B994",
    iconSuccess: "#30A46B",
    iconError: "#DF4A34",
    iconWarning: "#F3A13F",
    glass010: "rgba(255, 255, 255, 0.1)",
    zIndex: "9999"
  },
  dark: {
    overlay: "rgba(0, 0, 0, 0.50)",
    backgroundPrimary: "#202020",
    backgroundInvert: "#FFFFFF",
    textPrimary: "#FFFFFF",
    textSecondary: "#9A9A9A",
    textTertiary: "#BBBBBB",
    textInvert: "#202020",
    borderPrimary: "#2A2A2A",
    borderPrimaryDark: "#363636",
    borderSecondary: "#4F4F4F",
    foregroundPrimary: "#252525",
    foregroundSecondary: "#2A2A2A",
    foregroundTertiary: "#363636",
    iconDefault: "#9A9A9A",
    iconInverse: "#FFFFFF"
  },
  light: {
    overlay: "rgba(230 , 230, 230, 0.5)",
    backgroundPrimary: "#FFFFFF",
    borderPrimaryDark: "#E9E9E9",
    backgroundInvert: "#202020",
    textPrimary: "#202020",
    textSecondary: "#9A9A9A",
    textTertiary: "#6C6C6C",
    textInvert: "#FFFFFF",
    borderPrimary: "#E9E9E9",
    borderSecondary: "#D0D0D0",
    foregroundPrimary: "#F3F3F3",
    foregroundSecondary: "#E9E9E9",
    foregroundTertiary: "#D0D0D0",
    iconDefault: "#9A9A9A",
    iconInverse: "#202020"
  }
};
var borderRadius = {
  "1": "4px",
  "2": "8px",
  "10": "10px",
  "3": "12px",
  "4": "16px",
  "6": "24px",
  "5": "20px",
  "8": "32px",
  "16": "64px",
  "20": "80px",
  "32": "128px",
  "64": "256px",
  "128": "512px",
  round: "9999px"
};
var spacing = {
  "0": "0px",
  "01": "2px",
  "1": "4px",
  "2": "8px",
  "3": "12px",
  "4": "16px",
  "5": "20px",
  "6": "24px",
  "7": "28px",
  "8": "32px",
  "9": "36px",
  "10": "40px",
  "12": "48px",
  "14": "56px",
  "16": "64px",
  "20": "80px",
  "32": "128px",
  "64": "256px"
};
var fontFamily = {
  regular: "KHTeka",
  mono: "KHTekaMono"
};
var fontWeight = {
  regular: "400",
  medium: "500"
};
var textSize = {
  h1: "50px",
  h2: "44px",
  h3: "38px",
  h4: "32px",
  h5: "26px",
  h6: "20px",
  large: "16px",
  medium: "14px",
  small: "12px"
};
var typography = {
  "h1-regular-mono": { lineHeight: "50px", letterSpacing: "-3px" },
  "h1-regular": { lineHeight: "50px", letterSpacing: "-1px" },
  "h1-medium": { lineHeight: "50px", letterSpacing: "-0.84px" },
  "h2-regular-mono": { lineHeight: "44px", letterSpacing: "-2.64px" },
  "h2-regular": { lineHeight: "44px", letterSpacing: "-0.88px" },
  "h2-medium": { lineHeight: "44px", letterSpacing: "-0.88px" },
  "h3-regular-mono": { lineHeight: "38px", letterSpacing: "-2.28px" },
  "h3-regular": { lineHeight: "38px", letterSpacing: "-0.76px" },
  "h3-medium": { lineHeight: "38px", letterSpacing: "-0.76px" },
  "h4-regular-mono": { lineHeight: "32px", letterSpacing: "-1.92px" },
  "h4-regular": { lineHeight: "32px", letterSpacing: "-0.32px" },
  "h4-medium": { lineHeight: "32px", letterSpacing: "-0.32px" },
  "h5-regular-mono": { lineHeight: "26px", letterSpacing: "-1.56px" },
  "h5-regular": { lineHeight: "26px", letterSpacing: "-0.26px" },
  "h5-medium": { lineHeight: "26px", letterSpacing: "-0.26px" },
  "h6-regular-mono": { lineHeight: "20px", letterSpacing: "-1.2px" },
  "h6-regular": { lineHeight: "20px", letterSpacing: "-0.6px" },
  "h6-medium": { lineHeight: "20px", letterSpacing: "-0.6px" },
  "lg-regular-mono": { lineHeight: "16px", letterSpacing: "-0.96px" },
  "lg-regular": { lineHeight: "18px", letterSpacing: "-0.16px" },
  "lg-medium": { lineHeight: "18px", letterSpacing: "-0.16px" },
  "md-regular-mono": { lineHeight: "14px", letterSpacing: "-0.84px" },
  "md-regular": { lineHeight: "16px", letterSpacing: "-0.14px" },
  "md-medium": { lineHeight: "16px", letterSpacing: "-0.14px" },
  "sm-regular-mono": { lineHeight: "12px", letterSpacing: "-0.72px" },
  "sm-regular": { lineHeight: "14px", letterSpacing: "-0.12px" },
  "sm-medium": { lineHeight: "14px", letterSpacing: "-0.12px" }
};
var easings = {
  "ease-out-power-2": "cubic-bezier(0.23, 0.09, 0.08, 1.13)",
  "ease-out-power-1": "cubic-bezier(0.12, 0.04, 0.2, 1.06)",
  "ease-in-power-2": "cubic-bezier(0.92, -0.13, 0.77, 0.91)",
  "ease-in-power-1": "cubic-bezier(0.88, -0.06, 0.8, 0.96)",
  "ease-inout-power-2": "cubic-bezier(0.77, 0.09, 0.23, 1.13)",
  "ease-inout-power-1": "cubic-bezier(0.88, 0.04, 0.12, 1.06)"
};
var durations = {
  xl: "400ms",
  lg: "200ms",
  md: "125ms",
  sm: "75ms"
};
var styles = {
  colors,
  fontFamily,
  fontWeight,
  textSize,
  typography,
  tokens: {
    core: tokens.core,
    theme: tokens.dark
  },
  borderRadius,
  spacing,
  durations,
  easings
};

// node_modules/@reown/appkit-ui/dist/esm/src/utils/ThemeHelperUtil.js
var PREFIX_VAR = "--apkt";
var ThemeHelperUtil = {
  createCSSVariables(styles2) {
    const cssVariables = {};
    const cssVariablesVarPrefix = {};
    function createVars(_styles, parent, currentVar = "") {
      for (const [styleKey, styleValue] of Object.entries(_styles)) {
        const variable = currentVar ? `${currentVar}-${styleKey}` : styleKey;
        if (styleValue && typeof styleValue === "object" && Object.keys(styleValue).length) {
          parent[styleKey] = {};
          createVars(styleValue, parent[styleKey], variable);
        } else if (typeof styleValue === "string") {
          parent[styleKey] = `${PREFIX_VAR}-${variable}`;
        }
      }
    }
    function addVarsPrefix(_styles, parent) {
      for (const [key, value] of Object.entries(_styles)) {
        if (value && typeof value === "object") {
          parent[key] = {};
          addVarsPrefix(value, parent[key]);
        } else if (typeof value === "string") {
          parent[key] = `var(${value})`;
        }
      }
    }
    createVars(styles2, cssVariables);
    addVarsPrefix(cssVariables, cssVariablesVarPrefix);
    return { cssVariables, cssVariablesVarPrefix };
  },
  assignCSSVariables(vars2, styles2) {
    const assignedCSSVariables = {};
    function assignVars(_vars, _styles, variable) {
      for (const [varKey, varValue] of Object.entries(_vars)) {
        const nextVariable = variable ? `${variable}-${varKey}` : varKey;
        const styleValues = _styles[varKey];
        if (varValue && typeof varValue === "object") {
          assignVars(varValue, styleValues, nextVariable);
        } else if (typeof styleValues === "string") {
          assignedCSSVariables[`${PREFIX_VAR}-${nextVariable}`] = styleValues;
        }
      }
    }
    assignVars(vars2, styles2);
    return assignedCSSVariables;
  },
  createRootStyles(theme, themeVariables) {
    const styles2 = {
      ...styles,
      tokens: { ...styles.tokens, theme: theme === "light" ? tokens.light : tokens.dark }
    };
    const { cssVariables } = ThemeHelperUtil.createCSSVariables(styles2);
    const assignedCSSVariables = ThemeHelperUtil.assignCSSVariables(cssVariables, styles2);
    const w3mVariables = ThemeHelperUtil.generateW3MVariables(themeVariables);
    const w3mOverrides = ThemeHelperUtil.generateW3MOverrides(themeVariables);
    const scaledVariables = ThemeHelperUtil.generateScaledVariables(themeVariables);
    const baseVariables = ThemeHelperUtil.generateBaseVariables(assignedCSSVariables);
    const allVariables = {
      ...assignedCSSVariables,
      ...baseVariables,
      ...w3mVariables,
      ...w3mOverrides,
      ...scaledVariables
    };
    const colorMixVariables = ThemeHelperUtil.applyColorMixToVariables(themeVariables, allVariables);
    const finalVariables = {
      ...allVariables,
      ...colorMixVariables
    };
    const rootStyles = Object.entries(finalVariables).map(([key, style]) => `${key}:${style.replace("/[:;{}</>]/g", "")};`).join("");
    return `:root {${rootStyles}}`;
  },
  generateW3MVariables(themeVariables) {
    if (!themeVariables) {
      return {};
    }
    const variables = {};
    variables["--w3m-font-family"] = themeVariables["--w3m-font-family"] || "KHTeka";
    variables["--w3m-accent"] = themeVariables["--w3m-accent"] || "#0988F0";
    variables["--w3m-color-mix"] = themeVariables["--w3m-color-mix"] || "#000";
    variables["--w3m-color-mix-strength"] = `${themeVariables["--w3m-color-mix-strength"] || 0}%`;
    variables["--w3m-font-size-master"] = themeVariables["--w3m-font-size-master"] || "10px";
    variables["--w3m-border-radius-master"] = themeVariables["--w3m-border-radius-master"] || "4px";
    return variables;
  },
  generateW3MOverrides(themeVariables) {
    if (!themeVariables) {
      return {};
    }
    const overrides = {};
    if (themeVariables["--w3m-accent"]) {
      const accentColor = themeVariables["--w3m-accent"];
      overrides["--apkt-tokens-core-iconAccentPrimary"] = accentColor;
      overrides["--apkt-tokens-core-borderAccentPrimary"] = accentColor;
      overrides["--apkt-tokens-core-textAccentPrimary"] = accentColor;
      overrides["--apkt-tokens-core-backgroundAccentPrimary"] = accentColor;
    }
    if (themeVariables["--w3m-font-family"]) {
      overrides["--apkt-fontFamily-regular"] = themeVariables["--w3m-font-family"];
    }
    if (themeVariables["--w3m-z-index"]) {
      overrides["--apkt-tokens-core-zIndex"] = `${themeVariables["--w3m-z-index"]}`;
    }
    return overrides;
  },
  generateScaledVariables(themeVariables) {
    if (!themeVariables) {
      return {};
    }
    const scaledVars = {};
    if (themeVariables["--w3m-font-size-master"]) {
      const masterSize = parseFloat(themeVariables["--w3m-font-size-master"].replace("px", ""));
      scaledVars["--apkt-textSize-h1"] = `${Number(masterSize) * 5}px`;
      scaledVars["--apkt-textSize-h2"] = `${Number(masterSize) * 4.4}px`;
      scaledVars["--apkt-textSize-h3"] = `${Number(masterSize) * 3.8}px`;
      scaledVars["--apkt-textSize-h4"] = `${Number(masterSize) * 3.2}px`;
      scaledVars["--apkt-textSize-h5"] = `${Number(masterSize) * 2.6}px`;
      scaledVars["--apkt-textSize-h6"] = `${Number(masterSize) * 2}px`;
      scaledVars["--apkt-textSize-large"] = `${Number(masterSize) * 1.6}px`;
      scaledVars["--apkt-textSize-medium"] = `${Number(masterSize) * 1.4}px`;
      scaledVars["--apkt-textSize-small"] = `${Number(masterSize) * 1.2}px`;
    }
    if (themeVariables["--w3m-border-radius-master"]) {
      const masterRadius = parseFloat(themeVariables["--w3m-border-radius-master"].replace("px", ""));
      scaledVars["--apkt-borderRadius-1"] = `${Number(masterRadius)}px`;
      scaledVars["--apkt-borderRadius-2"] = `${Number(masterRadius) * 2}px`;
      scaledVars["--apkt-borderRadius-3"] = `${Number(masterRadius) * 3}px`;
      scaledVars["--apkt-borderRadius-4"] = `${Number(masterRadius) * 4}px`;
      scaledVars["--apkt-borderRadius-5"] = `${Number(masterRadius) * 5}px`;
      scaledVars["--apkt-borderRadius-6"] = `${Number(masterRadius) * 6}px`;
      scaledVars["--apkt-borderRadius-8"] = `${Number(masterRadius) * 8}px`;
      scaledVars["--apkt-borderRadius-16"] = `${Number(masterRadius) * 16}px`;
      scaledVars["--apkt-borderRadius-20"] = `${Number(masterRadius) * 20}px`;
      scaledVars["--apkt-borderRadius-32"] = `${Number(masterRadius) * 32}px`;
      scaledVars["--apkt-borderRadius-64"] = `${Number(masterRadius) * 64}px`;
      scaledVars["--apkt-borderRadius-128"] = `${Number(masterRadius) * 128}px`;
    }
    return scaledVars;
  },
  generateColorMixCSS(themeVariables, allVariables) {
    if (!themeVariables?.["--w3m-color-mix"] || !themeVariables["--w3m-color-mix-strength"]) {
      return "";
    }
    const colorMix = themeVariables["--w3m-color-mix"];
    const strength = themeVariables["--w3m-color-mix-strength"];
    if (!strength || strength === 0) {
      return "";
    }
    const colorVariables = Object.keys(allVariables || {}).filter((key) => {
      const isColorToken = key.includes("-tokens-core-background") || key.includes("-tokens-core-text") || key.includes("-tokens-core-border") || key.includes("-tokens-core-foreground") || key.includes("-tokens-core-icon") || key.includes("-tokens-theme-background") || key.includes("-tokens-theme-text") || key.includes("-tokens-theme-border") || key.includes("-tokens-theme-foreground") || key.includes("-tokens-theme-icon");
      const isDimensional = key.includes("-borderRadius-") || key.includes("-spacing-") || key.includes("-textSize-") || key.includes("-fontFamily-") || key.includes("-fontWeight-") || key.includes("-typography-") || key.includes("-duration-") || key.includes("-ease-") || key.includes("-path-") || key.includes("-width-") || key.includes("-height-") || key.includes("-visual-size-") || key.includes("-modal-width") || key.includes("-cover");
      return isColorToken && !isDimensional;
    });
    if (colorVariables.length === 0) {
      return "";
    }
    const colorMixVariables = colorVariables.map((key) => {
      const originalValue = allVariables?.[key] || "";
      if (originalValue.includes("color-mix") || originalValue.startsWith("#") || originalValue.startsWith("rgb")) {
        return `${key}: color-mix(in srgb, ${colorMix} ${strength}%, ${originalValue});`;
      }
      return `${key}: color-mix(in srgb, ${colorMix} ${strength}%, var(${key}-base, ${originalValue}));`;
    }).join("");
    return ` @supports (background: color-mix(in srgb, white 50%, black)) {
      :root {
        ${colorMixVariables}
      }
    }`;
  },
  generateBaseVariables(assignedCSSVariables) {
    const baseVariables = {};
    const themeBackgroundPrimary = assignedCSSVariables["--apkt-tokens-theme-backgroundPrimary"];
    if (themeBackgroundPrimary) {
      baseVariables["--apkt-tokens-theme-backgroundPrimary-base"] = themeBackgroundPrimary;
    }
    const coreBackgroundAccentPrimary = assignedCSSVariables["--apkt-tokens-core-backgroundAccentPrimary"];
    if (coreBackgroundAccentPrimary) {
      baseVariables["--apkt-tokens-core-backgroundAccentPrimary-base"] = coreBackgroundAccentPrimary;
    }
    return baseVariables;
  },
  applyColorMixToVariables(themeVariables, allVariables) {
    const colorMixVariables = {};
    if (allVariables?.["--apkt-tokens-theme-backgroundPrimary"]) {
      colorMixVariables["--apkt-tokens-theme-backgroundPrimary"] = "var(--apkt-tokens-theme-backgroundPrimary-base)";
    }
    if (allVariables?.["--apkt-tokens-core-backgroundAccentPrimary"]) {
      colorMixVariables["--apkt-tokens-core-backgroundAccentPrimary"] = "var(--apkt-tokens-core-backgroundAccentPrimary-base)";
    }
    if (!themeVariables?.["--w3m-color-mix"] || !themeVariables["--w3m-color-mix-strength"]) {
      return colorMixVariables;
    }
    const colorMix = themeVariables["--w3m-color-mix"];
    const strength = themeVariables["--w3m-color-mix-strength"];
    if (!strength || strength === 0) {
      return colorMixVariables;
    }
    const colorVariables = Object.keys(allVariables || {}).filter((key) => {
      const isColorToken = key.includes("-tokens-core-background") || key.includes("-tokens-core-text") || key.includes("-tokens-core-border") || key.includes("-tokens-core-foreground") || key.includes("-tokens-core-icon") || key.includes("-tokens-theme-background") || key.includes("-tokens-theme-text") || key.includes("-tokens-theme-border") || key.includes("-tokens-theme-foreground") || key.includes("-tokens-theme-icon") || key.includes("-tokens-theme-overlay");
      const isDimensional = key.includes("-borderRadius-") || key.includes("-spacing-") || key.includes("-textSize-") || key.includes("-fontFamily-") || key.includes("-fontWeight-") || key.includes("-typography-") || key.includes("-duration-") || key.includes("-ease-") || key.includes("-path-") || key.includes("-width-") || key.includes("-height-") || key.includes("-visual-size-") || key.includes("-modal-width") || key.includes("-cover");
      return isColorToken && !isDimensional;
    });
    if (colorVariables.length === 0) {
      return colorMixVariables;
    }
    colorVariables.forEach((key) => {
      const originalValue = allVariables?.[key] || "";
      if (key.endsWith("-base")) {
        return;
      }
      if (key === "--apkt-tokens-theme-backgroundPrimary" || key === "--apkt-tokens-core-backgroundAccentPrimary") {
        colorMixVariables[key] = `color-mix(in srgb, ${colorMix} ${strength}%, var(${key}-base))`;
      } else if (originalValue.includes("color-mix") || originalValue.startsWith("#") || originalValue.startsWith("rgb")) {
        colorMixVariables[key] = `color-mix(in srgb, ${colorMix} ${strength}%, ${originalValue})`;
      } else {
        colorMixVariables[key] = `color-mix(in srgb, ${colorMix} ${strength}%, var(${key}-base, ${originalValue}))`;
      }
    });
    return colorMixVariables;
  }
};
var { cssVariablesVarPrefix: vars } = ThemeHelperUtil.createCSSVariables(styles);
function css2(strings, ...values) {
  return css(strings, ...values.map((value) => typeof value === "function" ? unsafeCSS(value(vars)) : unsafeCSS(value)));
}

// node_modules/@reown/appkit-ui/dist/esm/src/utils/ThemeUtil.js
var apktTag = void 0;
var themeTag = void 0;
var darkModeTag = void 0;
var lightModeTag = void 0;
var currentThemeVariables = void 0;
var fonts = {
  "KHTeka-500-woff2": "https://fonts.reown.com/KHTeka-Medium.woff2",
  "KHTeka-400-woff2": "https://fonts.reown.com/KHTeka-Regular.woff2",
  "KHTeka-300-woff2": "https://fonts.reown.com/KHTeka-Light.woff2",
  "KHTekaMono-400-woff2": "https://fonts.reown.com/KHTekaMono-Regular.woff2",
  "KHTeka-500-woff": "https://fonts.reown.com/KHTeka-Light.woff",
  "KHTeka-400-woff": "https://fonts.reown.com/KHTeka-Regular.woff",
  "KHTeka-300-woff": "https://fonts.reown.com/KHTeka-Light.woff",
  "KHTekaMono-400-woff": "https://fonts.reown.com/KHTekaMono-Regular.woff"
};
function createAppKitTheme(themeVariables, theme = "dark") {
  if (apktTag) {
    document.head.removeChild(apktTag);
  }
  apktTag = document.createElement("style");
  apktTag.textContent = ThemeHelperUtil.createRootStyles(theme, themeVariables);
  document.head.appendChild(apktTag);
}
function initializeTheming(themeVariables, themeMode = "dark") {
  currentThemeVariables = themeVariables;
  themeTag = document.createElement("style");
  darkModeTag = document.createElement("style");
  lightModeTag = document.createElement("style");
  themeTag.textContent = createRootStyles(themeVariables).core.cssText;
  darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
  lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  document.head.appendChild(themeTag);
  document.head.appendChild(darkModeTag);
  document.head.appendChild(lightModeTag);
  createAppKitTheme(themeVariables, themeMode);
  setColorTheme(themeMode);
  if (!themeVariables?.["--w3m-font-family"]) {
    for (const [key, url] of Object.entries(fonts)) {
      const link = document.createElement("link");
      link.rel = "preload";
      link.href = url;
      link.as = "font";
      link.type = key.includes("woff2") ? "font/woff2" : "font/woff";
      link.crossOrigin = "anonymous";
      document.head.appendChild(link);
    }
  }
  setColorTheme(themeMode);
}
function setColorTheme(themeMode = "dark") {
  if (darkModeTag && lightModeTag && apktTag) {
    if (themeMode === "light") {
      createAppKitTheme(currentThemeVariables, themeMode);
      darkModeTag.removeAttribute("media");
      lightModeTag.media = "enabled";
    } else {
      createAppKitTheme(currentThemeVariables, themeMode);
      lightModeTag.removeAttribute("media");
      darkModeTag.media = "enabled";
    }
  }
}
function setThemeVariables(_themeVariables) {
  currentThemeVariables = _themeVariables;
  if (themeTag && darkModeTag && lightModeTag) {
    themeTag.textContent = createRootStyles(_themeVariables).core.cssText;
    darkModeTag.textContent = createRootStyles(_themeVariables).dark.cssText;
    lightModeTag.textContent = createRootStyles(_themeVariables).light.cssText;
    if (_themeVariables?.["--w3m-font-family"]) {
      const fontFamily2 = _themeVariables["--w3m-font-family"];
      themeTag.textContent = themeTag.textContent?.replace("font-family: KHTeka", `font-family: ${fontFamily2}`);
      darkModeTag.textContent = darkModeTag.textContent?.replace("font-family: KHTeka", `font-family: ${fontFamily2}`);
      lightModeTag.textContent = lightModeTag.textContent?.replace("font-family: KHTeka", `font-family: ${fontFamily2}`);
    }
  }
  if (apktTag) {
    const currentMode = lightModeTag?.media === "enabled" ? "light" : "dark";
    createAppKitTheme(_themeVariables, currentMode);
  }
}
function createRootStyles(_themeVariables) {
  const hasCustomFontFamily = Boolean(_themeVariables?.["--w3m-font-family"]);
  return {
    core: css`
      ${hasCustomFontFamily ? css`` : css`
            @font-face {
              font-family: 'KHTeka';
              src:
                url(${unsafeCSS(fonts["KHTeka-400-woff2"])}) format('woff2'),
                url(${unsafeCSS(fonts["KHTeka-400-woff"])}) format('woff');
              font-weight: 400;
              font-style: normal;
              font-display: swap;
            }

            @font-face {
              font-family: 'KHTeka';
              src:
                url(${unsafeCSS(fonts["KHTeka-300-woff2"])}) format('woff2'),
                url(${unsafeCSS(fonts["KHTeka-300-woff"])}) format('woff');
              font-weight: 300;
              font-style: normal;
            }

            @font-face {
              font-family: 'KHTekaMono';
              src:
                url(${unsafeCSS(fonts["KHTekaMono-400-woff2"])}) format('woff2'),
                url(${unsafeCSS(fonts["KHTekaMono-400-woff"])}) format('woff');
              font-weight: 400;
              font-style: normal;
            }

            @font-face {
              font-family: 'KHTeka';
              src:
                url(${unsafeCSS(fonts["KHTeka-400-woff2"])}) format('woff2'),
                url(${unsafeCSS(fonts["KHTeka-400-woff"])}) format('woff');
              font-weight: 400;
              font-style: normal;
            }
          `}

      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --apkt-modal-width: 370px;

        --apkt-visual-size-inherit: inherit;
        --apkt-visual-size-sm: 40px;
        --apkt-visual-size-md: 55px;
        --apkt-visual-size-lg: 80px;

        --apkt-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --apkt-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --apkt-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --apkt-width-network-sm: 36px;
        --apkt-width-network-md: 48px;
        --apkt-width-network-lg: 86px;

        --apkt-duration-dynamic: 0ms;
        --apkt-height-network-sm: 40px;
        --apkt-height-network-md: 54px;
        --apkt-height-network-lg: 96px;
      }
    `,
    dark: css`
      :root {
      }
    `,
    light: css`
      :root {
      }
    `
  };
}
var resetStyles = css`
  div,
  span,
  iframe,
  a,
  img,
  form,
  button,
  label,
  *::after,
  *::before {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    backface-visibility: hidden;
  }

  :host {
    font-family: var(--apkt-fontFamily-regular);
  }
`;
var elementStyles = css`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;

    will-change: background-color, color, border, box-shadow, width, height, transform, opacity;
    outline: none;
    border: none;
    text-decoration: none;
    transition:
      background-color var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      color var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      border var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      box-shadow var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      width var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      height var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      transform var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      opacity var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      scale var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      border-radius var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2);
    will-change:
      background-color, color, border, box-shadow, width, height, transform, opacity, scale,
      border-radius;
  }

  a:active:not([disabled]),
  button:active:not([disabled]) {
    scale: 0.975;
    transform-origin: center;
  }

  button:disabled {
    cursor: default;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`;

// node_modules/@reown/appkit-ui/dist/esm/src/utils/UiHelperUtil.js
var DECIMAL_POINT = ".";
var UiHelperUtil = {
  getSpacingStyles(spacing2, index) {
    if (Array.isArray(spacing2)) {
      return spacing2[index] ? `var(--apkt-spacing-${spacing2[index]})` : void 0;
    } else if (typeof spacing2 === "string") {
      return `var(--apkt-spacing-${spacing2})`;
    }
    return void 0;
  },
  getFormattedDate(date) {
    return new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" }).format(date);
  },
  formatCurrency(amount = 0, options = {}) {
    const numericAmount = Number(amount);
    if (isNaN(numericAmount)) {
      return "$0.00";
    }
    const formatter = new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
      ...options
    });
    return formatter.format(numericAmount);
  },
  getHostName(url) {
    try {
      const newUrl = new URL(url);
      return newUrl.hostname;
    } catch (error) {
      return "";
    }
  },
  getTruncateString({ string, charsStart, charsEnd, truncate }) {
    if (string.length <= charsStart + charsEnd) {
      return string;
    }
    if (truncate === "end") {
      return `${string.substring(0, charsStart)}...`;
    } else if (truncate === "start") {
      return `...${string.substring(string.length - charsEnd)}`;
    }
    return `${string.substring(0, Math.floor(charsStart))}...${string.substring(string.length - Math.floor(charsEnd))}`;
  },
  generateAvatarColors(address) {
    const hash = address.toLowerCase().replace(/^0x/iu, "").replace(/[^a-f0-9]/gu, "");
    const baseColor = hash.substring(0, 6).padEnd(6, "0");
    const rgbColor = this.hexToRgb(baseColor);
    const masterBorderRadius = getComputedStyle(document.documentElement).getPropertyValue("--w3m-border-radius-master");
    const radius = Number(masterBorderRadius?.replace("px", ""));
    const edge = 100 - 3 * radius;
    const gradientCircle = `${edge}% ${edge}% at 65% 40%`;
    const colors2 = [];
    for (let i2 = 0; i2 < 5; i2 += 1) {
      const tintedColor = this.tintColor(rgbColor, 0.15 * i2);
      colors2.push(`rgb(${tintedColor[0]}, ${tintedColor[1]}, ${tintedColor[2]})`);
    }
    return `
    --local-color-1: ${colors2[0]};
    --local-color-2: ${colors2[1]};
    --local-color-3: ${colors2[2]};
    --local-color-4: ${colors2[3]};
    --local-color-5: ${colors2[4]};
    --local-radial-circle: ${gradientCircle}
   `;
  },
  hexToRgb(hex) {
    const bigint = parseInt(hex, 16);
    const r2 = bigint >> 16 & 255;
    const g = bigint >> 8 & 255;
    const b = bigint & 255;
    return [r2, g, b];
  },
  tintColor(rgb, tint) {
    const [r2, g, b] = rgb;
    const tintedR = Math.round(r2 + (255 - r2) * tint);
    const tintedG = Math.round(g + (255 - g) * tint);
    const tintedB = Math.round(b + (255 - b) * tint);
    return [tintedR, tintedG, tintedB];
  },
  isNumber(character) {
    const regex = {
      number: /^[0-9]+$/u
    };
    return regex.number.test(character);
  },
  getColorTheme(theme) {
    if (theme) {
      return theme;
    } else if (typeof window !== "undefined" && window.matchMedia && typeof window.matchMedia === "function") {
      if (window.matchMedia("(prefers-color-scheme: dark)")?.matches) {
        return "dark";
      }
      return "light";
    }
    return "dark";
  },
  splitBalance(input) {
    const parts = input.split(".");
    if (parts.length === 2) {
      return [parts[0], parts[1]];
    }
    return ["0", "00"];
  },
  roundNumber(number, threshold, fixed) {
    const roundedNumber = number.toString().length >= threshold ? Number(number).toFixed(fixed) : number;
    return roundedNumber;
  },
  cssDurationToNumber(duration) {
    if (duration.endsWith("s")) {
      return Number(duration.replace("s", "")) * 1e3;
    } else if (duration.endsWith("ms")) {
      return Number(duration.replace("ms", ""));
    }
    return 0;
  },
  maskInput({ value, decimals, integers }) {
    value = value.replace(",", ".");
    if (value === DECIMAL_POINT) {
      return `0${DECIMAL_POINT}`;
    }
    const [integerPart = "", decimalsPart] = value.split(DECIMAL_POINT).map((p) => p.replace(/[^0-9]/gu, ""));
    const limitedInteger = integers ? integerPart.substring(0, integers) : integerPart;
    const cleanIntegerPart = limitedInteger.length === 2 ? String(Number(limitedInteger)) : limitedInteger;
    const cleanDecimalsPart = typeof decimals === "number" ? decimalsPart?.substring(0, decimals) : decimalsPart;
    const canIncludeDecimals = typeof decimals !== "number" || decimals > 0;
    const maskValue = typeof cleanDecimalsPart === "string" && canIncludeDecimals ? [cleanIntegerPart, cleanDecimalsPart].join(DECIMAL_POINT) : cleanIntegerPart;
    return maskValue ?? "";
  },
  capitalize(value) {
    if (!value) {
      return "";
    }
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
};

// node_modules/@reown/appkit-ui/dist/esm/src/utils/WebComponentsUtil.js
function standardCustomElement(tagName, descriptor) {
  const { kind, elements } = descriptor;
  return {
    kind,
    elements,
    finisher(clazz) {
      if (!customElements.get(tagName)) {
        customElements.define(tagName, clazz);
      }
    }
  };
}
function legacyCustomElement(tagName, clazz) {
  if (!customElements.get(tagName)) {
    customElements.define(tagName, clazz);
  }
  return clazz;
}
function customElement(tagName) {
  return function create(classOrDescriptor) {
    return typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
  };
}

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil3 = {
  ACCOUNT_TABS: [{ label: "Tokens" }, { label: "Activity" }],
  SECURE_SITE_ORIGIN: (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_ORIGIN"] : void 0) || "https://secure.walletconnect.org",
  VIEW_DIRECTION: {
    Next: "next",
    Prev: "prev"
  },
  DEFAULT_CONNECT_METHOD_ORDER: ["email", "social", "wallet"],
  ANIMATION_DURATIONS: {
    HeaderText: 120,
    ModalHeight: 150,
    ViewTransition: 150
  },
  VIEWS_WITH_LEGAL_FOOTER: [
    "Connect",
    "ConnectWallets",
    "OnRampTokenSelect",
    "OnRampFiatSelect",
    "OnRampProviders"
  ],
  VIEWS_WITH_DEFAULT_FOOTER: ["Networks"]
};

export {
  OnRampController,
  EnsController,
  WcHelpersUtil,
  AdapterBlueprint,
  SIWXUtil,
  WalletConnectConnector,
  AlertController,
  SwapController,
  TooltipController,
  baseUSDC,
  baseSepoliaUSDC,
  ModalUtil,
  ConstantsUtil3 as ConstantsUtil,
  css,
  defaultConverter,
  notEqual,
  html,
  svg,
  mathml,
  noChange,
  nothing,
  _$LH,
  LitElement,
  vars,
  css2,
  initializeTheming,
  setColorTheme,
  setThemeVariables,
  resetStyles,
  elementStyles,
  UiHelperUtil,
  customElement
};
/*! Bundled license information:

@walletconnect/utils/dist/index.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

lit-html/development/lit-html.js:
@lit/reactive-element/development/reactive-element.js:
lit-element/development/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=chunk-NB4XU6WD.js.map
